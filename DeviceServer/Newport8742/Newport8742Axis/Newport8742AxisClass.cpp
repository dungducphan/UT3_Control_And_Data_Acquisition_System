/*----- PROTECTED REGION ID(Newport8742AxisClass.cpp) ENABLED START -----*/
static const char *RcsId      = "$Id:  $";
static const char *TagName    = "$Name:  $";
static const char *CvsPath    = "$Source:  $";
static const char *SvnPath    = "$HeadURL:  $";
static const char *HttpServer = "http://www.esrf.eu/computing/cs/tango/tango_doc/ds_doc/";
//=============================================================================
//
// file :        Newport8742AxisClass.cpp
//
// description : C++ source for the Newport8742AxisClass. A singleton
//               class derived from DeviceClass. It implements the
//               command list and all properties and methods required
//               by the «name» once per process.
//
// project :     .
//
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL:  $
//
// CVS only:
// $Source:  $
// $Log:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <Newport8742AxisClass.h>

/*----- PROTECTED REGION END -----*/	//	Newport8742AxisClass.cpp

//-------------------------------------------------------------------
/**
 *	Create Newport8742AxisClass singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_Newport8742Axis_class(const char *name) {
		return Newport8742Axis_ns::Newport8742AxisClass::init(name);
	}
}

namespace Newport8742Axis_ns
{
//===================================================================
//	Initialize pointer for singleton pattern
//===================================================================
Newport8742AxisClass *Newport8742AxisClass::_instance = NULL;

//--------------------------------------------------------
/**
 * method : 		Newport8742AxisClass::Newport8742AxisClass(string &s)
 * description : 	constructor for the Newport8742AxisClass
 *
 * @param s	The class name
 */
//--------------------------------------------------------
Newport8742AxisClass::Newport8742AxisClass(string &s):Tango::DeviceClass(s)
{
	cout2 << "Entering Newport8742AxisClass constructor" << endl;
	set_default_property();
	write_class_property();

	/*----- PROTECTED REGION ID(Newport8742AxisClass::constructor) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	Newport8742AxisClass::constructor

	cout2 << "Leaving Newport8742AxisClass constructor" << endl;
}

//--------------------------------------------------------
/**
 * method : 		Newport8742AxisClass::~Newport8742AxisClass()
 * description : 	destructor for the Newport8742AxisClass
 */
//--------------------------------------------------------
Newport8742AxisClass::~Newport8742AxisClass()
{
	/*----- PROTECTED REGION ID(Newport8742AxisClass::destructor) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	Newport8742AxisClass::destructor

	_instance = NULL;
}


//--------------------------------------------------------
/**
 * method : 		Newport8742AxisClass::init
 * description : 	Create the object if not already done.
 *                  Otherwise, just return a pointer to the object
 *
 * @param	name	The class name
 */
//--------------------------------------------------------
Newport8742AxisClass *Newport8742AxisClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new Newport8742AxisClass(s);
		}
		catch (bad_alloc &)
		{
			throw;
		}
	}
	return _instance;
}

//--------------------------------------------------------
/**
 * method : 		Newport8742AxisClass::instance
 * description : 	Check if object already created,
 *                  and return a pointer to the object
 */
//--------------------------------------------------------
Newport8742AxisClass *Newport8742AxisClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}



//===================================================================
//	Command execution method calls
//===================================================================
//--------------------------------------------------------
/**
 * method : 		StopMoveClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *StopMoveClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "StopMoveClass::execute(): arrived" << endl;
	((static_cast<Newport8742Axis *>(device))->stop_move());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		CalibrateClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *CalibrateClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "CalibrateClass::execute(): arrived" << endl;
	Tango::DevDouble argin;
	extract(in_any, argin);
	((static_cast<Newport8742Axis *>(device))->calibrate(argin));
	return new CORBA::Any();
}


//===================================================================
//	Properties management
//===================================================================
//--------------------------------------------------------
/**
 *	Method      : Newport8742AxisClass::get_class_property()
 *	Description : Get the class property for specified name.
 */
//--------------------------------------------------------
Tango::DbDatum Newport8742AxisClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, returns  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : Newport8742AxisClass::get_default_device_property()
 *	Description : Return the default value for device property.
 */
//--------------------------------------------------------
Tango::DbDatum Newport8742AxisClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : Newport8742AxisClass::get_default_class_property()
 *	Description : Return the default value for class property.
 */
//--------------------------------------------------------
Tango::DbDatum Newport8742AxisClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}


//--------------------------------------------------------
/**
 *	Method      : Newport8742AxisClass::set_default_property()
 *	Description : Set default property (class and device) for wizard.
 *                For each property, add to wizard property name and description.
 *                If default value has been set, add it to wizard property and
 *                store it in a DbDatum.
 */
//--------------------------------------------------------
void Newport8742AxisClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;
	vector<string>	vect_data;

	//	Set Default Class Properties

	//	Set Default device Properties
	prop_name = "NewPortCtrlDevice";
	prop_desc = "";
	prop_def  = """";
	vect_data.clear();
	vect_data.push_back("""");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "AxisNumber";
	prop_desc = "Number of axis (1-4)";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
}

//--------------------------------------------------------
/**
 *	Method      : Newport8742AxisClass::write_class_property()
 *	Description : Set class description fields as property in database
 */
//--------------------------------------------------------
void Newport8742AxisClass::write_class_property()
{
	//	First time, check if database used
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("Axis class for motors connected to NewPort8742 controller");
	description << str_desc;
	data.push_back(description);

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("TANGO_BASE_CLASS");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	get_db_class()->put_property(data);
}

//===================================================================
//	Factory methods
//===================================================================

//--------------------------------------------------------
/**
 *	Method      : Newport8742AxisClass::device_factory()
 *	Description : Create the device object(s)
 *                and store them in the device list
 */
//--------------------------------------------------------
void Newport8742AxisClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{
	/*----- PROTECTED REGION ID(Newport8742AxisClass::device_factory_before) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	Newport8742AxisClass::device_factory_before

	//	Create devices and add it into the device list
	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
		device_list.push_back(new Newport8742Axis(this, (*devlist_ptr)[i]));
	}

	//	Manage dynamic attributes if any
	erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

	//	Export devices to the outside world
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++)
	{
		//	Add dynamic attributes if any
		Newport8742Axis *dev = static_cast<Newport8742Axis *>(device_list[device_list.size()-i]);
		dev->add_dynamic_attributes();

		//	Check before if database used.
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(dev);
		else
			export_device(dev, dev->get_name().c_str());
	}

	/*----- PROTECTED REGION ID(Newport8742AxisClass::device_factory_after) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	Newport8742AxisClass::device_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : Newport8742AxisClass::attribute_factory()
 *	Description : Create the attribute object(s)
 *                and store them in the attribute list
 */
//--------------------------------------------------------
void Newport8742AxisClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	/*----- PROTECTED REGION ID(Newport8742AxisClass::attribute_factory_before) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	Newport8742AxisClass::attribute_factory_before
	//	Attribute : Conversion
	ConversionAttrib	*conversion = new ConversionAttrib();
	Tango::UserDefaultAttrProp	conversion_prop;
	conversion_prop.set_description("conversion factor for steps to units");
	//	label	not set for Conversion
	//	unit	not set for Conversion
	//	standard_unit	not set for Conversion
	//	display_unit	not set for Conversion
	//	format	not set for Conversion
	//	max_value	not set for Conversion
	//	min_value	not set for Conversion
	//	max_alarm	not set for Conversion
	//	min_alarm	not set for Conversion
	//	max_warning	not set for Conversion
	//	min_warning	not set for Conversion
	//	delta_t	not set for Conversion
	//	delta_val	not set for Conversion
	
	conversion->set_default_properties(conversion_prop);
	//	Not Polled
	conversion->set_disp_level(Tango::OPERATOR);
	conversion->set_memorized();
	conversion->set_memorized_init(true);
	att_list.push_back(conversion);

	//	Attribute : Position
	PositionAttrib	*position = new PositionAttrib();
	Tango::UserDefaultAttrProp	position_prop;
	position_prop.set_description("The current or target position in units");
	//	label	not set for Position
	//	unit	not set for Position
	//	standard_unit	not set for Position
	//	display_unit	not set for Position
	//	format	not set for Position
	//	max_value	not set for Position
	//	min_value	not set for Position
	//	max_alarm	not set for Position
	//	min_alarm	not set for Position
	//	max_warning	not set for Position
	//	min_warning	not set for Position
	//	delta_t	not set for Position
	//	delta_val	not set for Position
	
	position->set_default_properties(position_prop);
	//	Not Polled
	position->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(position);

	//	Attribute : UnitLimitMin
	UnitLimitMinAttrib	*unitlimitmin = new UnitLimitMinAttrib();
	Tango::UserDefaultAttrProp	unitlimitmin_prop;
	unitlimitmin_prop.set_description("Minimum position limit. If not set, will default to -1.\n\nWhen both min and max are set to 0, the limit will be ignored.\n\nThe motors do not have end switches and the controller does not stop\ngenerating pulses when the wall is hit. If this happens, your position\nis lost. So make sure you set the limits properly.");
	//	label	not set for UnitLimitMin
	//	unit	not set for UnitLimitMin
	//	standard_unit	not set for UnitLimitMin
	//	display_unit	not set for UnitLimitMin
	//	format	not set for UnitLimitMin
	//	max_value	not set for UnitLimitMin
	//	min_value	not set for UnitLimitMin
	//	max_alarm	not set for UnitLimitMin
	//	min_alarm	not set for UnitLimitMin
	//	max_warning	not set for UnitLimitMin
	//	min_warning	not set for UnitLimitMin
	//	delta_t	not set for UnitLimitMin
	//	delta_val	not set for UnitLimitMin
	
	unitlimitmin->set_default_properties(unitlimitmin_prop);
	//	Not Polled
	unitlimitmin->set_disp_level(Tango::OPERATOR);
	unitlimitmin->set_memorized();
	unitlimitmin->set_memorized_init(true);
	att_list.push_back(unitlimitmin);

	//	Attribute : UnitLimitMax
	UnitLimitMaxAttrib	*unitlimitmax = new UnitLimitMaxAttrib();
	Tango::UserDefaultAttrProp	unitlimitmax_prop;
	unitlimitmax_prop.set_description("Maximum position limit. If not set, will default to 1.\n\nWhen both min and max are set to 0, the limit will be ignored.\n\nThe motors do not have end switches and the controller does not stop\ngenerating pulses when the wall is hit. If this happens, your position\nis lost. So make sure you set the limits properly.");
	//	label	not set for UnitLimitMax
	//	unit	not set for UnitLimitMax
	//	standard_unit	not set for UnitLimitMax
	//	display_unit	not set for UnitLimitMax
	//	format	not set for UnitLimitMax
	//	max_value	not set for UnitLimitMax
	//	min_value	not set for UnitLimitMax
	//	max_alarm	not set for UnitLimitMax
	//	min_alarm	not set for UnitLimitMax
	//	max_warning	not set for UnitLimitMax
	//	min_warning	not set for UnitLimitMax
	//	delta_t	not set for UnitLimitMax
	//	delta_val	not set for UnitLimitMax
	
	unitlimitmax->set_default_properties(unitlimitmax_prop);
	//	Not Polled
	unitlimitmax->set_disp_level(Tango::OPERATOR);
	unitlimitmax->set_memorized();
	unitlimitmax->set_memorized_init(true);
	att_list.push_back(unitlimitmax);

	//	Attribute : MotorType
	MotorTypeAttrib	*motortype = new MotorTypeAttrib();
	Tango::UserDefaultAttrProp	motortype_prop;
	motortype_prop.set_description("The type of the connected motor.\n\n0: no motor connected\n1: motor type unknown\n2: tiny motor\n3: standard motor");
	//	label	not set for MotorType
	//	unit	not set for MotorType
	//	standard_unit	not set for MotorType
	//	display_unit	not set for MotorType
	//	format	not set for MotorType
	//	max_value	not set for MotorType
	//	min_value	not set for MotorType
	//	max_alarm	not set for MotorType
	//	min_alarm	not set for MotorType
	//	max_warning	not set for MotorType
	//	min_warning	not set for MotorType
	//	delta_t	not set for MotorType
	//	delta_val	not set for MotorType
	
	motortype->set_default_properties(motortype_prop);
	//	Not Polled
	motortype->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(motortype);

	//	Attribute : Speed
	SpeedAttrib	*speed = new SpeedAttrib();
	Tango::UserDefaultAttrProp	speed_prop;
	speed_prop.set_description("The axis velocity in steps/sec , min 0, max 2000");
	//	label	not set for Speed
	//	unit	not set for Speed
	//	standard_unit	not set for Speed
	//	display_unit	not set for Speed
	//	format	not set for Speed
	//	max_value	not set for Speed
	//	min_value	not set for Speed
	//	max_alarm	not set for Speed
	//	min_alarm	not set for Speed
	//	max_warning	not set for Speed
	//	min_warning	not set for Speed
	//	delta_t	not set for Speed
	//	delta_val	not set for Speed
	
	speed->set_default_properties(speed_prop);
	//	Not Polled
	speed->set_disp_level(Tango::OPERATOR);
	speed->set_memorized();
	speed->set_memorized_init(true);
	att_list.push_back(speed);

	//	Attribute : Acceleration
	AccelerationAttrib	*acceleration = new AccelerationAttrib();
	Tango::UserDefaultAttrProp	acceleration_prop;
	acceleration_prop.set_description("The axis acceleraion in steps/sec2, min 1, max 200000");
	//	label	not set for Acceleration
	//	unit	not set for Acceleration
	//	standard_unit	not set for Acceleration
	//	display_unit	not set for Acceleration
	//	format	not set for Acceleration
	//	max_value	not set for Acceleration
	//	min_value	not set for Acceleration
	//	max_alarm	not set for Acceleration
	//	min_alarm	not set for Acceleration
	//	max_warning	not set for Acceleration
	//	min_warning	not set for Acceleration
	//	delta_t	not set for Acceleration
	//	delta_val	not set for Acceleration
	
	acceleration->set_default_properties(acceleration_prop);
	//	Not Polled
	acceleration->set_disp_level(Tango::OPERATOR);
	acceleration->set_memorized();
	acceleration->set_memorized_init(true);
	att_list.push_back(acceleration);

	//	Attribute : StoredPosition
	StoredPositionAttrib	*storedposition = new StoredPositionAttrib();
	Tango::UserDefaultAttrProp	storedposition_prop;
	storedposition_prop.set_description("Position in steps. This attribute is memorized an updated after every\nmove. The value is used to recalibrate the position value (command 'DH')at server start\nin case the controller was switched off. Never edit this manually. ");
	//	label	not set for StoredPosition
	//	unit	not set for StoredPosition
	//	standard_unit	not set for StoredPosition
	//	display_unit	not set for StoredPosition
	//	format	not set for StoredPosition
	//	max_value	not set for StoredPosition
	//	min_value	not set for StoredPosition
	//	max_alarm	not set for StoredPosition
	//	min_alarm	not set for StoredPosition
	//	max_warning	not set for StoredPosition
	//	min_warning	not set for StoredPosition
	//	delta_t	not set for StoredPosition
	//	delta_val	not set for StoredPosition
	
	storedposition->set_default_properties(storedposition_prop);
	//	Not Polled
	storedposition->set_disp_level(Tango::EXPERT);
	storedposition->set_memorized();
	storedposition->set_memorized_init(true);
	att_list.push_back(storedposition);


	//	Create a list of static attributes
	create_static_attribute_list(get_class_attr()->get_attr_list());
	/*----- PROTECTED REGION ID(Newport8742AxisClass::attribute_factory_after) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	Newport8742AxisClass::attribute_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : Newport8742AxisClass::pipe_factory()
 *	Description : Create the pipe object(s)
 *                and store them in the pipe list
 */
//--------------------------------------------------------
void Newport8742AxisClass::pipe_factory()
{
	/*----- PROTECTED REGION ID(Newport8742AxisClass::pipe_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	Newport8742AxisClass::pipe_factory_before
	/*----- PROTECTED REGION ID(Newport8742AxisClass::pipe_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	Newport8742AxisClass::pipe_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : Newport8742AxisClass::command_factory()
 *	Description : Create the command object(s)
 *                and store them in the command list
 */
//--------------------------------------------------------
void Newport8742AxisClass::command_factory()
{
	/*----- PROTECTED REGION ID(Newport8742AxisClass::command_factory_before) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	Newport8742AxisClass::command_factory_before


	//	Command StopMove
	StopMoveClass	*pStopMoveCmd =
		new StopMoveClass("StopMove",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pStopMoveCmd);

	//	Command Calibrate
	CalibrateClass	*pCalibrateCmd =
		new CalibrateClass("Calibrate",
			Tango::DEV_DOUBLE, Tango::DEV_VOID,
			"position value to be defined as current position",
			"",
			Tango::OPERATOR);
	command_list.push_back(pCalibrateCmd);

	/*----- PROTECTED REGION ID(Newport8742AxisClass::command_factory_after) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	Newport8742AxisClass::command_factory_after
}

//===================================================================
//	Dynamic attributes related methods
//===================================================================

//--------------------------------------------------------
/**
 * method : 		Newport8742AxisClass::create_static_attribute_list
 * description : 	Create the a list of static attributes
 *
 * @param	att_list	the ceated attribute list
 */
//--------------------------------------------------------
void Newport8742AxisClass::create_static_attribute_list(vector<Tango::Attr *> &att_list)
{
	for (unsigned long i=0 ; i<att_list.size() ; i++)
	{
		string att_name(att_list[i]->get_name());
		transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
		defaultAttList.push_back(att_name);
	}

	cout2 << defaultAttList.size() << " attributes in default list" << endl;

	/*----- PROTECTED REGION ID(Newport8742AxisClass::create_static_att_list) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	Newport8742AxisClass::create_static_att_list
}


//--------------------------------------------------------
/**
 * method : 		Newport8742AxisClass::erase_dynamic_attributes
 * description : 	delete the dynamic attributes if any.
 *
 * @param	devlist_ptr	the device list pointer
 * @param	list of all attributes
 */
//--------------------------------------------------------
void Newport8742AxisClass::erase_dynamic_attributes(const Tango::DevVarStringArray *devlist_ptr, vector<Tango::Attr *> &att_list)
{
	Tango::Util *tg = Tango::Util::instance();

	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		Tango::DeviceImpl *dev_impl = tg->get_device_by_name(((string)(*devlist_ptr)[i]).c_str());
		Newport8742Axis *dev = static_cast<Newport8742Axis *> (dev_impl);

		vector<Tango::Attribute *> &dev_att_list = dev->get_device_attr()->get_attribute_list();
		vector<Tango::Attribute *>::iterator ite_att;
		for (ite_att=dev_att_list.begin() ; ite_att != dev_att_list.end() ; ++ite_att)
		{
			string att_name((*ite_att)->get_name_lower());
			if ((att_name == "state") || (att_name == "status"))
				continue;
			vector<string>::iterator ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
			if (ite_str == defaultAttList.end())
			{
				cout2 << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << endl;
				Tango::Attribute &att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
				dev->remove_attribute(att_list[att.get_attr_idx()], true, false);
				--ite_att;
			}
		}
	}
	/*----- PROTECTED REGION ID(Newport8742AxisClass::erase_dynamic_attributes) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	Newport8742AxisClass::erase_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Method      : Newport8742AxisClass::get_attr_object_by_name()
 *	Description : returns Tango::Attr * object found by name
 */
//--------------------------------------------------------
Tango::Attr *Newport8742AxisClass::get_attr_object_by_name(vector<Tango::Attr *> &att_list, string attname)
{
	vector<Tango::Attr *>::iterator it;
	for (it=att_list.begin() ; it<att_list.end() ; ++it)
		if ((*it)->get_name()==attname)
			return (*it);
	//	Attr does not exist
	return NULL;
}


/*----- PROTECTED REGION ID(Newport8742AxisClass::Additional Methods) ENABLED START -----*/

	/*----- PROTECTED REGION END -----*/	//	Newport8742AxisClass::Additional Methods
} //	namespace
