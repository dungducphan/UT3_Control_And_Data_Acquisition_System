/*----- PROTECTED REGION ID(StanfordDG645Channel.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        StanfordDG645Channel.cpp
//
// description : C++ source for the StanfordDG645Channel class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               StanfordDG645Channel are implemented in this file.
//
// project :     StanfordDG645Channel
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <StanfordDG645Channel.h>
#include <StanfordDG645ChannelClass.h>

/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel.cpp

/**
 *  StanfordDG645Channel class description:
 *    Device server for a single delay channel.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  Inherited (no method)
//  Status        |  Inherited (no method)
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  OutputAmplitude  |  Tango::DevFloat	Scalar
//  OutputOffset     |  Tango::DevFloat	Scalar
//  OutputWidth      |  Tango::DevDouble	Scalar
//  TriggerDelay     |  Tango::DevDouble	Scalar
//================================================================

namespace StanfordDG645Channel_ns
{
/*----- PROTECTED REGION ID(StanfordDG645Channel::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Channel::StanfordDG645Channel()
 *	Description : Constructors for a Tango device
 *                implementing the classStanfordDG645Channel
 */
//--------------------------------------------------------
StanfordDG645Channel::StanfordDG645Channel(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(StanfordDG645Channel::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::constructor_1
}
//--------------------------------------------------------
StanfordDG645Channel::StanfordDG645Channel(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(StanfordDG645Channel::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::constructor_2
}
//--------------------------------------------------------
StanfordDG645Channel::StanfordDG645Channel(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(StanfordDG645Channel::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Channel::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void StanfordDG645Channel::delete_device()
{
	DEBUG_STREAM << "StanfordDG645Channel::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Channel::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	hooks->unregisterHook(DG645_HOOK_CONTROLLER_INIT, connect_controller);
	hooks->unregisterHook(DG645_HOOK_CONTROLLER_DELETE, disconnect_controller);
	hooks->unregisterHook(DG645_HOOK_CONNECTION_START, set_connection_state);
	hooks->unregisterHook(DG645_HOOK_CONNECTION_STOP, set_connection_state);
	disconnect_controller(this);

	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::delete_device
	delete[] attr_OutputAmplitude_read;
	delete[] attr_OutputOffset_read;
	delete[] attr_OutputWidth_read;
	delete[] attr_TriggerDelay_read;
}

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Channel::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void StanfordDG645Channel::init_device()
{
	DEBUG_STREAM << "StanfordDG645Channel::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Channel::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	attr_OutputAmplitude_read = new Tango::DevFloat[1];
	attr_OutputOffset_read = new Tango::DevFloat[1];
	attr_OutputWidth_read = new Tango::DevDouble[1];
	attr_TriggerDelay_read = new Tango::DevDouble[1];
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(StanfordDG645Channel::init_device) ENABLED START -----*/
	
	//	Initialize device
	
	// initialise hooks
	hooks = Hooks_ns::getHooks(DG645_HOOKS_SIZE);
	hooks->registerHook(DG645_HOOK_CONTROLLER_INIT, connect_controller, this);
	hooks->registerHook(DG645_HOOK_CONTROLLER_DELETE, disconnect_controller, this);
	hooks->registerHook(DG645_HOOK_CONNECTION_START, set_connection_state, this);
	hooks->registerHook(DG645_HOOK_CONNECTION_STOP, set_connection_state, this);

	// connect to controller
	connect_controller((void *)this);
	if(controller == NULL)
	{
		error(DG645_ERR_CONTROLLER, "chn", error_msg(DG645_ERR_CONTROLLER), "init_device()", false, true);
		set_state(Tango::FAULT);
		return;
	}
	set_connection_state((void *)this);

	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::init_device
}

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Channel::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void StanfordDG645Channel::get_device_property()
{
	/*----- PROTECTED REGION ID(StanfordDG645Channel::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("ControlDevicePath"));
	dev_prop.push_back(Tango::DbDatum("Channel"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on StanfordDG645ChannelClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		StanfordDG645ChannelClass	*ds_class =
			(static_cast<StanfordDG645ChannelClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize ControlDevicePath from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  controlDevicePath;
		else {
			//	Try to initialize ControlDevicePath from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  controlDevicePath;
		}
		//	And try to extract ControlDevicePath value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  controlDevicePath;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize Channel from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  channel;
		else {
			//	Try to initialize Channel from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  channel;
		}
		//	And try to extract Channel value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  channel;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

	}

	/*----- PROTECTED REGION ID(StanfordDG645Channel::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	if(channel > 4)
	{
		error(DG645_ERR_CHANNEL, "chn", error_msg(DG645_ERR_CHANNEL), "get_device_property()", false, true);
		set_state(Tango::FAULT);
	}

	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Channel::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void StanfordDG645Channel::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		append_status(tms.str());
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(StanfordDG645Channel::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;
		
		/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Channel::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void StanfordDG645Channel::always_executed_hook()
{
	DEBUG_STREAM << "StanfordDG645Channel::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					get_status().c_str(),
					(const char *)"StanfordDG645Channel::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(StanfordDG645Channel::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Channel::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void StanfordDG645Channel::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "StanfordDG645Channel::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Channel::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Channel::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void StanfordDG645Channel::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "StanfordDG645Channel::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Channel::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute OutputAmplitude related method
 *	Description: The amplitude for the output. It might be positive or negative and has to be in the range between 0.5V and 5V. The absolute level may not exceed 6V.
 *               
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Channel::read_OutputAmplitude(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Channel::read_OutputAmplitude(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Channel::read_OutputAmplitude) ENABLED START -----*/
	int err;
	float value = 0;
	Tango::DevString ans;
	char cmd[] = "LAMP?0";
	cmd[5] = 48 + channel;

	if((err = controller->send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "chn", error_msg(err), "read_OutputAmplitude()");
	}
	else if(sscanf(ans, "%f", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "chn", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_OutputAmplitude()");
	}
	else
	{
		CORBA::string_free(ans);
		*attr_OutputAmplitude_read = value;
	}

	//	Set the attribute value
	attr.set_value(attr_OutputAmplitude_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::read_OutputAmplitude
}
//--------------------------------------------------------
/**
 *	Write attribute OutputAmplitude related method
 *	Description: The amplitude for the output. It might be positive or negative and has to be in the range between 0.5V and 5V. The absolute level may not exceed 6V.
 *               
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Channel::write_OutputAmplitude(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Channel::write_OutputAmplitude(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Channel::write_OutputAmplitude) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int err = 0;

	sprintf(buffer, "LAMP %d,%f", channel, w_val);
	if((err = controller->send_cmd(buffer)))
	{
		error(err, err < 0 && err > -256 ? "dg645" : "chn", error_msg(err), "write_OutputAmplitude()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::write_OutputAmplitude
}
//--------------------------------------------------------
/**
 *	Read attribute OutputOffset related method
 *	Description: The DC offset for the output. It has to be in the range between -2V and 2V. The absolute level may not exceed 6V.
 *               
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Channel::read_OutputOffset(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Channel::read_OutputOffset(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Channel::read_OutputOffset) ENABLED START -----*/
	int err;
	float value = 0;
	Tango::DevString ans;
	char cmd[] = "LOFF?0";
	cmd[5] = 48 + channel;

	if((err = controller->send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "chn", error_msg(err), "read_OutputOffset()");
	}
	else if(sscanf(ans, "%f", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "chn", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_OutputOffset()");
	}
	else
	{
		CORBA::string_free(ans);
		*attr_OutputOffset_read = value;
	}

	//	Set the attribute value
	attr.set_value(attr_OutputOffset_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::read_OutputOffset
}
//--------------------------------------------------------
/**
 *	Write attribute OutputOffset related method
 *	Description: The DC offset for the output. It has to be in the range between -2V and 2V. The absolute level may not exceed 6V.
 *               
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Channel::write_OutputOffset(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Channel::write_OutputOffset(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Channel::write_OutputOffset) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int err = 0;

	sprintf(buffer, "LOFF %d,%f", channel, w_val);
	if((err = controller->send_cmd(buffer)))
	{
		error(err, err < 0 && err > -256 ? "dg645" : "chn", error_msg(err), "write_OutputOffset()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::write_OutputOffset
}
//--------------------------------------------------------
/**
 *	Read attribute OutputWidth related method
 *	Description: The pulse width for the output.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Channel::read_OutputWidth(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Channel::read_OutputWidth(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Channel::read_OutputWidth) ENABLED START -----*/
	int err;
	double value = 0;
	Tango::DevString ans;
	char cmd[] = "DLAY?0";
	cmd[5] = 49 + 2 * channel;

	if((err = controller->send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "chn", error_msg(err), "read_OutputWidth()");
	}
	else if(sscanf(&ans[2], "%lf", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "chn", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_OutputWidth()");
	}
	else
	{
		CORBA::string_free(ans);
		*attr_OutputWidth_read = value * 1000;
	}

	//	Set the attribute value
	attr.set_value(attr_OutputWidth_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::read_OutputWidth
}
//--------------------------------------------------------
/**
 *	Write attribute OutputWidth related method
 *	Description: The pulse width for the output.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Channel::write_OutputWidth(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Channel::write_OutputWidth(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Channel::write_OutputWidth) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int err = 0;

	if(channel == 0)
	{
		error(DG645_ERR_ILLEGAL_CHANNEL, "chn", error_msg(DG645_ERR_ILLEGAL_CHANNEL), "write_TriggerDelay()", true, false);
	}

	sprintf(buffer, "DLAY%d,%d,%f", 2 * channel + 1, 2 * channel, w_val / 1000);
	if((err = controller->send_cmd(buffer)))
	{
		error(err, err < 0 && err > -256 ? "dg645" : "chn", error_msg(err), "write_OutputWidth()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::write_OutputWidth
}
//--------------------------------------------------------
/**
 *	Read attribute TriggerDelay related method
 *	Description: The delay between t0 and the trigger of the channel.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Channel::read_TriggerDelay(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Channel::read_TriggerDelay(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Channel::read_TriggerDelay) ENABLED START -----*/
	int err;
	double value = 0;
	Tango::DevString ans;
	char cmd[] = "DLAY?0";
	cmd[5] = 48 + 2 * channel;

	if((err = controller->send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "chn", error_msg(err), "read_TriggerDelay()");
	}
	else if(sscanf(&ans[2], "%lf", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "chn", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_TriggerDelay()");
	}
	else
	{
		CORBA::string_free(ans);
		*attr_TriggerDelay_read = value * 1000;
	}

	//	Set the attribute value
	attr.set_value(attr_TriggerDelay_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::read_TriggerDelay
}
//--------------------------------------------------------
/**
 *	Write attribute TriggerDelay related method
 *	Description: The delay between t0 and the trigger of the channel.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Channel::write_TriggerDelay(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Channel::write_TriggerDelay(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Channel::write_TriggerDelay) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int err = 0;

	if(channel == 0)
	{
		error(DG645_ERR_ILLEGAL_CHANNEL, "chn", error_msg(DG645_ERR_ILLEGAL_CHANNEL), "write_TriggerDelay()", true, false);
	}

	sprintf(buffer, "DLAY%d,0,%f", 2 * channel, w_val / 1000);
	if((err = controller->send_cmd(buffer)))
	{
		error(err, err < 0 && err > -256 ? "dg645" : "chn", error_msg(err), "write_TriggerDelay()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::write_TriggerDelay
}

//--------------------------------------------------------
/**
 *	Read attribute TriggerPrescale related method
 *	Description: This is a divider to the original delay cyle frequency. If set to values > 1, only every Nth delay cyle will trigger the output. The valid range covers [1..2^30-1], 1 will disable the feature. Makes use of the advanced triggering mode.
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Channel::read_TriggerPrescale(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Channel::read_TriggerPrescale(Tango::Attribute &attr) entering... " << endl;
	Tango::DevULong	*att_value = get_TriggerPrescale_data_ptr(attr.get_name());
	/*----- PROTECTED REGION ID(StanfordDG645Channel::read_TriggerPrescale) ENABLED START -----*/
	int err;
	unsigned long value = 0;
	Tango::DevString ans;
	char cmd[] = "PRES?0";
	cmd[5] = 48 + channel;

	if((err = controller->send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "chn", error_msg(err), "read_TriggerPrescale()");
	}
	else if(sscanf(ans, "%lu", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "chn", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_TriggerPrescale()");
	}
	else
	{
		CORBA::string_free(ans);
		*att_value = value;
	}

	//	Set the attribute value
	attr.set_value(att_value);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::read_TriggerPrescale
}
//--------------------------------------------------------
/**
 *	Write attribute TriggerPrescale related method
 *	Description: This is a divider to the original delay cyle frequency. If set to values > 1, only every Nth delay cyle will trigger the output. The valid range covers [1..2^30-1], 1 will disable the feature. Makes use of the advanced triggering mode.
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Channel::write_TriggerPrescale(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Channel::write_TriggerPrescale(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevULong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Channel::write_TriggerPrescale) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int err = 0;

	sprintf(buffer, "ADVT1;PRES %d,%d", channel, w_val);
	if((err = controller->send_cmd(buffer)))
	{
		error(err, err < 0 && err > -256 ? "dg645" : "chn", error_msg(err), "write_TriggerPrescale()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::write_TriggerPrescale
}
//--------------------------------------------------------
/**
 *	Read attribute TriggerPhase related method
 *	Description: This determines the phase at which the associated output is enabled. The output is enabled when the prescaler counter equals the phase factor.
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Channel::read_TriggerPhase(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Channel::read_TriggerPhase(Tango::Attribute &attr) entering... " << endl;
	Tango::DevULong	*att_value = get_TriggerPhase_data_ptr(attr.get_name());
	/*----- PROTECTED REGION ID(StanfordDG645Channel::read_TriggerPhase) ENABLED START -----*/
	int err;
	unsigned long value = 0;
	Tango::DevString ans;
	char cmd[] = "PHAS?0";
	cmd[5] = 48 + channel;

	if((err = controller->send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "chn", error_msg(err), "read_TriggerPhase()");
	}
	else if(sscanf(ans, "%lu", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "chn", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_TriggerPhase()");
	}
	else
	{
		CORBA::string_free(ans);
		*att_value = value;
	}

	//	Set the attribute value
	attr.set_value(att_value);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::read_TriggerPhase
}
//--------------------------------------------------------
/**
 *	Write attribute TriggerPhase related method
 *	Description: This determines the phase at which the associated output is enabled. The output is enabled when the prescaler counter equals the phase factor.
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Channel::write_TriggerPhase(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Channel::write_TriggerPhase(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevULong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Channel::write_TriggerPhase) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int err = 0;

	sprintf(buffer, "ADVT1;PHAS %d,%d", channel, w_val);
	if((err = controller->send_cmd(buffer)))
	{
		error(err, err < 0 && err > -256 ? "dg645" : "chn", error_msg(err), "write_TriggerPhase()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::write_TriggerPhase
}
//--------------------------------------------------------
/**
 *	Read attribute BurstMode related method
 *	Description: If true, the T0 output is enabled for all delay cycles of the burst. Otherwise it is enabled for first delay cycle of the burst only.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Channel::read_BurstMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Channel::read_BurstMode(Tango::Attribute &attr) entering... " << endl;
	Tango::DevBoolean	*att_value = get_BurstMode_data_ptr(attr.get_name());
	/*----- PROTECTED REGION ID(StanfordDG645Channel::read_BurstMode) ENABLED START -----*/
	int err;
	unsigned char value = 0;
	Tango::DevString ans;
	char cmd[] = "BURT?";

	if((err = controller->send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "chn", error_msg(err), "read_BurstMode()");
	}
	else if(sscanf(ans, "%hhu", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "chn", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_BurstMode()");
	}
	else
	{
		CORBA::string_free(ans);
		*att_value = !(bool)value;
	}

	//	Set the attribute value
	attr.set_value(att_value);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::read_BurstMode
}
//--------------------------------------------------------
/**
 *	Write attribute BurstMode related method
 *	Description: If true, the T0 output is enabled for all delay cycles of the burst. Otherwise it is enabled for first delay cycle of the burst only.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Channel::write_BurstMode(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Channel::write_BurstMode(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Channel::write_BurstMode) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int err = 0;

	sprintf(buffer, "BURT%d", w_val == 0);
	if((err = controller->send_cmd(buffer)))
	{
		error(err, err < 0 && err > -256 ? "dg645" : "chn", error_msg(err), "write_TriggerDelay()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::write_BurstMode
}
//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Channel::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void StanfordDG645Channel::add_dynamic_attributes()
{
	//	Example to add dynamic attribute:
	//	Copy inside the following protected area to create instance(s) at startup.
	//	add_TriggerPrescale_dynamic_attribute("MyTriggerPrescaleAttribute");
	//	add_TriggerPhase_dynamic_attribute("MyTriggerPhaseAttribute");
	//	add_BurstMode_dynamic_attribute("MyBurstModeAttribute");
	
	/*----- PROTECTED REGION ID(StanfordDG645Channel::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	if(channel == DG645_CHANNEL_T0)
	{
		add_BurstMode_dynamic_attribute("BurstMode");
	}
	else
	{
		add_TriggerPrescale_dynamic_attribute("TriggerPrescale");
		add_TriggerPhase_dynamic_attribute("TriggerPhase");
	}

	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Channel::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void StanfordDG645Channel::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(StanfordDG645Channel::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::add_dynamic_commands
}

/*----- PROTECTED REGION ID(StanfordDG645Channel::namespace_ending) ENABLED START -----*/

//	Additional Methods
/**
 *	Method      : connect_controller
 *	Description : gets a pointer to the controller Tango device server
 */
//--------------------------------------------------------

void StanfordDG645Channel::connect_controller(void *arg)
{
	StanfordDG645Channel *server = (StanfordDG645Channel *)arg;
	Tango::Util *util = Tango::Util::instance();

	if(server->get_logger()->is_debug_enabled())
		server->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log <<
		"StanfordDG645Channel::connect_controller(void *arg) entering...  " << endl;

	try
	{
		server->controller = (StanfordDG645Control_ns::StanfordDG645Control *)util->get_device_by_name(server->controlDevicePath);
	}
	catch(Tango::DevFailed &e)
	{
		server->controller = NULL;
		return;
	}

	// register sub device
	util->get_sub_dev_diag().register_sub_device(server->get_name(), server->controlDevicePath);
	util->get_sub_dev_diag().store_sub_devices();

	// wait for controlling device to initialize
	for(int i=0; i<DG645_TASK_WAIT_TRIALS && server->controller->get_state() == Tango::UNKNOWN; i++)
		server->nsleep(DG645_TASK_WAIT_INTERVAL_NS);
}


//--------------------------------------------------------
/**
 *	Method      : disconnect_controller
 *	Description : resets the pointer to the controller Tango device server
 *	              called by the servers SERVER_DELETE hook
 */
//--------------------------------------------------------
void StanfordDG645Channel::disconnect_controller(void *arg)
{
	StanfordDG645Channel *server = (StanfordDG645Channel *)arg;

	if(server->get_logger()->is_debug_enabled())
		server->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log <<
		"StanfordDG645Channel::disconnect_controller(void *arg) entering...  " << endl;

	server->controller = NULL;
}


//--------------------------------------------------------
/**
 *	Method      : set_connection_state
 *	Description : sets the server state with respect to
 *	              the controller device connection
 */
//--------------------------------------------------------
void StanfordDG645Channel::set_connection_state(void *arg)
{
	StanfordDG645Channel *server = (StanfordDG645Channel *)arg;
	int err;
	char cmd[] = "LINK0,0";

	if(server->get_logger()->is_debug_enabled())
		server->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log <<
		"StanfordDG645Channel::set_connection_state(void *arg) entering...  " << endl;

	if(server->channel > 4)
		err = DG645_ERR_CHANNEL;
	else if(server->controller)
		err = server->controller->last_error;
	else
		err = DG645_ERR_CONTROLLER;

	if(server->channel < 5 && server->controller && server->controller->handle)
	{
		server->set_state(Tango::ON);
		server->set_status(Tango::StatusNotSet);
		// set linked delay channel
		if(server->channel > 0)
		{
			cmd[4] = 48 + 2 * server->channel;
			cmd[6] = 48;
			if((err = server->controller->send_cmd(cmd)))
				server->error(err, err < 0 && err > -256 ? "dg645" : "chn", server->error_msg(err), "set_connection_state()", false, true);
			cmd[4] = 49 + 2 * server->channel;
			cmd[6] = 48 + 2 * server->channel;
			if((err = server->controller->send_cmd(cmd)))
				server->error(err, err < 0 && err > -256 ? "dg645" : "chn", server->error_msg(err), "set_connection_state()", false, true);
		}
	}
	else
	{
		server->set_state(Tango::FAULT);
		server->error(err, err < 0 && err > -256 ? "dg645" : "chn", server->error_msg(err), "set_connection_state()", false, true);
	}
}


//--------------------------------------------------------
/**
 *	Method      : get_reason
 *	Description : parses a Tango exception and returns the underlying error code
 *
 *	@param const CORBA::Exception &e
 */
//--------------------------------------------------------
int StanfordDG645Channel::get_reason(const CORBA::Exception &e)
{

	const CORBA::UserException *ue;
	const Tango::DevFailed *te;
	const Tango::NamedDevFailedList *mdf;

	string reason = "";
	int ret;

	// If it is a CORBA::UserException
	if((ue = dynamic_cast<const CORBA::UserException *>(&e)) != NULL)
	{
		if((mdf = dynamic_cast<const Tango::NamedDevFailedList *>(&e)) != NULL)
		{
			if(mdf->errors.length() > 0)
			{
				reason = mdf->errors[0].reason.in();
			}
			else if(mdf->err_list.size() > 0)
			{
				reason = mdf->err_list[0].err_stack[0].reason.in();
			}
		}

		// Print the Tango::DevFailed exception contents
		else if((te = dynamic_cast<const Tango::DevFailed *>(&e)) != NULL)
		{
			if(te->errors.length() > 0)
			{
				reason = te->errors[0].reason.in();
			}
		}
	}

	ret = atoi(reason.c_str());
	return ret ? ret : DG645_ERR_UNKNOWN;
}


//--------------------------------------------------------
/**
 *	Method      : error_msg
 *	Description : return the message to an error code
 *
 *	@param int code
 *	@returns const char*
 */
//--------------------------------------------------------
const char inline *StanfordDG645Channel::error_msg(int code)
{
	if(code < 0)
		return StanfordDG645Common_ns::DG645ErrorMsgs(code);
	else
		return strerror(code);
}


//--------------------------------------------------------
/**
 *	Method      : error
 *	Description : Sign an error. It's printed to the info stream and,
 *	              depending on throw_exception, also thrown as a Tango exception
 *
 *	@param int code, const char *module, const char *msg, const char *origin,
 *	       bool throw_exception, bool set_status_string
 */
//--------------------------------------------------------
void StanfordDG645Channel::error(int code, const char *module, const char *msg, const char *origin, bool throw_exception, bool set_status_string)
{
	string buffer;
	char err[8];

	buffer.append(module);
	buffer.append(": ");
	buffer.append(msg);
	sprintf(err, "%i", code);

	ERROR_STREAM << buffer << ", error " << err << ", " << origin << endl;

	if(set_status_string)
	{
		status.assign(buffer);
		status.append(", error ");
		status.append(err);
		status.append(", ");
		status.append(origin);
		set_status(status);
	}

	if(throw_exception)
	{
		Tango::Except::throw_exception(CORBA::string_dup(err), CORBA::string_dup(buffer.c_str()), string(origin), Tango::ERR);
	}
}


//--------------------------------------------------------
/**
 *	Method      : nsleep
 *	Description : sleeps for nsec nano seconds
 *
 *	@param long nsec
 *	@returns int
 */
//--------------------------------------------------------
int StanfordDG645Channel::nsleep(long nsec)
{
  struct timespec ts;

  ts.tv_sec = nsec / 1000000000;
  ts.tv_nsec = nsec % 1000000000;

  return nanosleep(&ts, NULL);
}



/*----- PROTECTED REGION END -----*/	//	StanfordDG645Channel::namespace_ending
} //	namespace
