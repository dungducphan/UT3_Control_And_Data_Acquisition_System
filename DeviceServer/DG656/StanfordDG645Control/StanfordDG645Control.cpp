/*----- PROTECTED REGION ID(StanfordDG645Control.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        StanfordDG645Control.cpp
//
// description : C++ source for the StanfordDG645Control class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               StanfordDG645Control are implemented in this file.
//
// project :     StanfordDG645Control
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <StanfordDG645Control.h>
#include <StanfordDG645ControlClass.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control.cpp

/**
 *  StanfordDG645Control class description:
 *    Device server for the Stanford DG645 delay generator. Exports the connection to dedicated single channel device servers.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  Inherited (no method)
//  Status        |  Inherited (no method)
//  SingleShot    |  single_shot
//  LoadDefaults  |  load_defaults
//  LoadSettings  |  load_settings
//  SaveSettings  |  save_settings
//  WriteRead     |  write_read
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  TriggerMode            |  Tango::DevEnum	Scalar
//  TriggerRate            |  Tango::DevDouble	Scalar
//  TriggerThreshold       |  Tango::DevFloat	Scalar
//  TriggerHoldoff         |  Tango::DevDouble	Scalar
//  TriggerPrescale        |  Tango::DevULong	Scalar
//  BurstMode              |  Tango::DevBoolean	Scalar
//  BurstCount             |  Tango::DevULong	Scalar
//  BurstPeriod            |  Tango::DevDouble	Scalar
//  BurstDelay             |  Tango::DevDouble	Scalar
//  DeviceSerialNumber     |  Tango::DevString	Scalar
//  DeviceFirmwareVersion  |  Tango::DevString	Scalar
//================================================================

namespace StanfordDG645Control_ns
{
/*----- PROTECTED REGION ID(StanfordDG645Control::namespace_starting) ENABLED START -----*/

//	static initializations
omni_mutex StanfordDG645Control::connectionMutex;
omni_thread *(StanfordDG645Control::poll_thread) = NULL;
omni_thread *(StanfordDG645Control::reconnect_thread) = NULL;
/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Control::StanfordDG645Control()
 *	Description : Constructors for a Tango device
 *                implementing the classStanfordDG645Control
 */
//--------------------------------------------------------
StanfordDG645Control::StanfordDG645Control(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(StanfordDG645Control::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::constructor_1
}
//--------------------------------------------------------
StanfordDG645Control::StanfordDG645Control(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(StanfordDG645Control::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::constructor_2
}
//--------------------------------------------------------
StanfordDG645Control::StanfordDG645Control(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(StanfordDG645Control::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Control::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void StanfordDG645Control::delete_device()
{
	DEBUG_STREAM << "StanfordDG645Control::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::delete_device) ENABLED START -----*/
	
	// call hook
	hooks->executeHook(DG645_HOOK_CONTROLLER_DELETE);

	// stop polling thread
	running = false;
	for(int i=0; i<DG645_TASK_WAIT_TRIALS && poll_thread && poll_thread->state() == omni_thread::STATE_RUNNING; i++)
		nsleep(DG645_TASK_WAIT_INTERVAL_NS);
	if(!terminated)
		error(DG645_ERR_THREAD, "ctrl", error_msg(DG645_ERR_THREAD), "delete_device()", false, true);

	// free hardware info
	if(hardwareInfo)
		CORBA::string_free(hardwareInfo);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::delete_device
	delete[] attr_TriggerMode_read;
	delete[] attr_TriggerRate_read;
	delete[] attr_TriggerThreshold_read;
	delete[] attr_TriggerHoldoff_read;
	delete[] attr_TriggerPrescale_read;
	delete[] attr_BurstMode_read;
	delete[] attr_BurstCount_read;
	delete[] attr_BurstPeriod_read;
	delete[] attr_BurstDelay_read;
	delete[] attr_DeviceSerialNumber_read;
	delete[] attr_DeviceFirmwareVersion_read;
}

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Control::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void StanfordDG645Control::init_device()
{
	DEBUG_STREAM << "StanfordDG645Control::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::init_device_before) ENABLED START -----*/
	long t;
	running = false;
	terminated = true;
	connecting = false;
	handle = 0;
	last_error = 0;
	hardwareInfo = NULL;

	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	attr_TriggerMode_read = new TriggerModeEnum[1];
	attr_TriggerRate_read = new Tango::DevDouble[1];
	attr_TriggerThreshold_read = new Tango::DevFloat[1];
	attr_TriggerHoldoff_read = new Tango::DevDouble[1];
	attr_TriggerPrescale_read = new Tango::DevULong[1];
	attr_BurstMode_read = new Tango::DevBoolean[1];
	attr_BurstCount_read = new Tango::DevULong[1];
	attr_BurstPeriod_read = new Tango::DevDouble[1];
	attr_BurstDelay_read = new Tango::DevDouble[1];
	attr_DeviceSerialNumber_read = new Tango::DevString[1];
	attr_DeviceFirmwareVersion_read = new Tango::DevString[1];
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(StanfordDG645Control::init_device) ENABLED START -----*/
	emptyString[0] = 0;
	*attr_DeviceSerialNumber_read = emptyString;
	*attr_DeviceFirmwareVersion_read = emptyString;

	// initialise hooks
	hooks = Hooks_ns::getHooks(DG645_HOOKS_SIZE);
	hooks->executeHook(DG645_HOOK_CONTROLLER_INIT);

	// start poll thread
	poll_thread = omni_thread::create(&poll_state, (void *)this);

	// initialise connection
	reconnect(true);
	for(t=0; t<=DG645_TIMEOUT_S*1000000000 && connecting; t+=100000000)
		nsleep(100000000);
	if(t > DG645_TIMEOUT_S*1000000000)
		set_state(Tango::FAULT);
	set_status(Tango::StatusNotSet);

	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::init_device
}

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Control::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void StanfordDG645Control::get_device_property()
{
	/*----- PROTECTED REGION ID(StanfordDG645Control::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Host"));
	dev_prop.push_back(Tango::DbDatum("AutoReconnect"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on StanfordDG645ControlClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		StanfordDG645ControlClass	*ds_class =
			(static_cast<StanfordDG645ControlClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize Host from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  host;
		else {
			//	Try to initialize Host from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  host;
		}
		//	And try to extract Host value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  host;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize AutoReconnect from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  autoReconnect;
		else {
			//	Try to initialize AutoReconnect from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  autoReconnect;
		}
		//	And try to extract AutoReconnect value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  autoReconnect;

	}

	/*----- PROTECTED REGION ID(StanfordDG645Control::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Control::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void StanfordDG645Control::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		append_status(tms.str());
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(StanfordDG645Control::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;
		
		/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Control::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void StanfordDG645Control::always_executed_hook()
{
	DEBUG_STREAM << "StanfordDG645Control::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					get_status().c_str(),
					(const char *)"StanfordDG645Control::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(StanfordDG645Control::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Control::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void StanfordDG645Control::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "StanfordDG645Control::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Control::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void StanfordDG645Control::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "StanfordDG645Control::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute TriggerMode related method
 *	Description: Int - Internal triggering at rates from 100 �Hz to 10 MHz.
 *               ExtRisingEdge - External triggering on rising edges.
 *               ExtFallingEdge - External triggering on falling edges.
 *               SingleExtRisingEdge - Externally triggered single shot on a rising edges. Execute SingleShot command to arm the trigger.
 *               SingleExtFallingEdge - Externally triggered single shot on a falling edges. Execute SingleShot command to arm the trigger.
 *               Single - Single shot triggering. Initiated manually on the device or by executing the SingleShot command.
 *               Line - Trigger at the power line frequency.
 *
 *	Data type:	Tango::DevEnum (TriggerModeEnum)
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::read_TriggerMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::read_TriggerMode(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::read_TriggerMode) ENABLED START -----*/
	int err;
	char value = 0;
	Tango::DevString ans;
	char cmd[] = "TSRC?";

	if((err = send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "ctrl", error_msg(err), "read_TriggerMode()");
	}
	else if(sscanf(ans, "%hhd", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "ctrl", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_TriggerMode()");
	}
	else
	{
		CORBA::string_free(ans);
		*attr_TriggerMode_read = (TriggerModeEnum)value;
	}

	//	Set the attribute value
	attr.set_value(attr_TriggerMode_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::read_TriggerMode
}
//--------------------------------------------------------
/**
 *	Write attribute TriggerMode related method
 *	Description: Int - Internal triggering at rates from 100 �Hz to 10 MHz.
 *               ExtRisingEdge - External triggering on rising edges.
 *               ExtFallingEdge - External triggering on falling edges.
 *               SingleExtRisingEdge - Externally triggered single shot on a rising edges. Execute SingleShot command to arm the trigger.
 *               SingleExtFallingEdge - Externally triggered single shot on a falling edges. Execute SingleShot command to arm the trigger.
 *               Single - Single shot triggering. Initiated manually on the device or by executing the SingleShot command.
 *               Line - Trigger at the power line frequency.
 *
 *	Data type:	Tango::DevEnum (TriggerModeEnum)
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::write_TriggerMode(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::write_TriggerMode(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	TriggerModeEnum	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Control::write_TriggerMode) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int ret = 0;

	sprintf(buffer, "TSRC%d", (unsigned char)w_val);
	if((ret = send_cmd(buffer)))
	{
		error(ret, ret < 0 && ret > -256 ? "dg645" : "ctrl", error_msg(ret), "write_TriggerMode()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::write_TriggerMode
}
//--------------------------------------------------------
/**
 *	Read attribute TriggerRate related method
 *	Description: The frequency of the trigger generator used in internal mode. It can generate triggers at rates from 100 uHz to 10 MHz with 1 uHz resolution.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::read_TriggerRate(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::read_TriggerRate(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::read_TriggerRate) ENABLED START -----*/
	int err;
	double value = 0;
	Tango::DevString ans;
	char cmd[] = "TRAT?";

	if((err = send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "ctrl", error_msg(err), "read_TriggerRate()");
	}
	else if(sscanf(ans, "%lf", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "ctrl", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_TriggerRate()");
	}
	else
	{
		CORBA::string_free(ans);
		*attr_TriggerRate_read = value;
	}

	//	Set the attribute value
	attr.set_value(attr_TriggerRate_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::read_TriggerRate
}
//--------------------------------------------------------
/**
 *	Write attribute TriggerRate related method
 *	Description: The frequency of the trigger generator used in internal mode. It can generate triggers at rates from 100 uHz to 10 MHz with 1 uHz resolution.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::write_TriggerRate(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::write_TriggerRate(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Control::write_TriggerRate) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int ret = 0;

	sprintf(buffer, "TRAT%f", w_val);
	if((ret = send_cmd(buffer)))
	{
		error(ret, ret < 0 && ret > -256 ? "dg645" : "ctrl", error_msg(ret), "write_TriggerRate()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::write_TriggerRate
}
//--------------------------------------------------------
/**
 *	Read attribute TriggerThreshold related method
 *	Description: The Ext Trig input threshold range is +-3.5 VDC.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::read_TriggerThreshold(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::read_TriggerThreshold(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::read_TriggerThreshold) ENABLED START -----*/
	int err;
	float value = 0;
	Tango::DevString ans;
	char cmd[] = "TLVL?";

	if((err = send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "ctrl", error_msg(err), "read_TriggerThreshold()");
	}
	else if(sscanf(ans, "%f", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "ctrl", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_TriggerThreshold()");
	}
	else
	{
		CORBA::string_free(ans);
		*attr_TriggerThreshold_read = value;
	}

	//	Set the attribute value
	attr.set_value(attr_TriggerThreshold_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::read_TriggerThreshold
}
//--------------------------------------------------------
/**
 *	Write attribute TriggerThreshold related method
 *	Description: The Ext Trig input threshold range is +-3.5 VDC.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::write_TriggerThreshold(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::write_TriggerThreshold(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Control::write_TriggerThreshold) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int ret = 0;

	sprintf(buffer, "TLVL%f", w_val);
	if((ret = send_cmd(buffer)))
	{
		error(ret, ret < 0 && ret > -256 ? "dg645" : "ctrl", error_msg(ret), "write_TriggerThreshold()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::write_TriggerThreshold
}
//--------------------------------------------------------
/**
 *	Read attribute TriggerHoldoff related method
 *	Description: The minimum allowed time between successive triggers. For example, if the trigger holdoff is set to 10 ms, then successive triggers will be ignored until at least 10 ms have passed since the last accepted trigger. Makes use of the advanced triggering mode.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::read_TriggerHoldoff(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::read_TriggerHoldoff(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::read_TriggerHoldoff) ENABLED START -----*/
	int err;
	double value = 0;
	Tango::DevString ans;
	char cmd[] = "HOLD?";

	if((err = send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "ctrl", error_msg(err), "read_TriggerHoldoff()");
	}
	else if(sscanf(ans, "%lf", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "ctrl", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_TriggerHoldoff()");
	}
	else
	{
		CORBA::string_free(ans);
		*attr_TriggerHoldoff_read = value * 1000;
	}

	//	Set the attribute value
	attr.set_value(attr_TriggerHoldoff_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::read_TriggerHoldoff
}
//--------------------------------------------------------
/**
 *	Write attribute TriggerHoldoff related method
 *	Description: The minimum allowed time between successive triggers. For example, if the trigger holdoff is set to 10 ms, then successive triggers will be ignored until at least 10 ms have passed since the last accepted trigger. Makes use of the advanced triggering mode.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::write_TriggerHoldoff(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::write_TriggerHoldoff(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Control::write_TriggerHoldoff) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int ret = 0;

	sprintf(buffer, "ADVT1;HOLD%f", w_val / 1000);
	if((ret = send_cmd(buffer)))
	{
		error(ret, ret < 0 && ret > -256 ? "dg645" : "ctrl", error_msg(ret), "write_TriggerHoldoff()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::write_TriggerHoldoff
}
//--------------------------------------------------------
/**
 *	Read attribute TriggerPrescale related method
 *	Description: This is a divider to the original trigger frequency. If set to values > 1, only every Nth trigger will initiate a delay cyle. The valid range covers [1..2^30-1], 1 will disable the feature. Makes use of  the advanced triggering mode when.
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::read_TriggerPrescale(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::read_TriggerPrescale(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::read_TriggerPrescale) ENABLED START -----*/
	int err;
	unsigned long value = 0;
	Tango::DevString ans;
	char cmd[] = "PRES?0";

	if((err = send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "ctrl", error_msg(err), "read_TriggerPrescale()");
	}
	else if(sscanf(ans, "%lu", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "ctrl", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_TriggerPrescale()");
	}
	else
	{
		CORBA::string_free(ans);
		*attr_TriggerPrescale_read = value;
	}

	//	Set the attribute value
	attr.set_value(attr_TriggerPrescale_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::read_TriggerPrescale
}
//--------------------------------------------------------
/**
 *	Write attribute TriggerPrescale related method
 *	Description: This is a divider to the original trigger frequency. If set to values > 1, only every Nth trigger will initiate a delay cyle. The valid range covers [1..2^30-1], 1 will disable the feature. Makes use of  the advanced triggering mode when.
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::write_TriggerPrescale(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::write_TriggerPrescale(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevULong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Control::write_TriggerPrescale) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int ret = 0;

	sprintf(buffer, "ADVT1;PRES0,%u", w_val);
	if((ret = send_cmd(buffer)))
	{
		error(ret, ret < 0 && ret > -256 ? "dg645" : "ctrl", error_msg(ret), "write_TriggerPrescale()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::write_TriggerPrescale
}
//--------------------------------------------------------
/**
 *	Read attribute BurstMode related method
 *	Description: The delay generator will generate a burst of N delay cycles on each trigger when enabled.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::read_BurstMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::read_BurstMode(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::read_BurstMode) ENABLED START -----*/
	int err;
	unsigned char value = 0;
	Tango::DevString ans;
	char cmd[] = "BURM?";

	if((err = send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "ctrl", error_msg(err), "read_BurstMode()");
	}
	else if(sscanf(ans, "%hhu", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "ctrl", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_BurstMode()");
	}
	else
	{
		CORBA::string_free(ans);
		*attr_BurstMode_read = value;
	}

	//	Set the attribute value
	attr.set_value(attr_BurstMode_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::read_BurstMode
}
//--------------------------------------------------------
/**
 *	Write attribute BurstMode related method
 *	Description: The delay generator will generate a burst of N delay cycles on each trigger when enabled.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::write_BurstMode(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::write_BurstMode(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Control::write_BurstMode) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int ret = 0;

	sprintf(buffer, "BURM%u", w_val);
	if((ret = send_cmd(buffer)))
	{
		error(ret, ret < 0 && ret > -256 ? "dg645" : "ctrl", error_msg(ret), "write_BurstMode()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::write_BurstMode
}
//--------------------------------------------------------
/**
 *	Read attribute BurstCount related method
 *	Description: The number of delay cyles generated on each trigger when in burst mode. The valid range covers [1..2^32-1].
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::read_BurstCount(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::read_BurstCount(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::read_BurstCount) ENABLED START -----*/
	int err;
	unsigned long value = 0;
	Tango::DevString ans;
	char cmd[] = "BURC?";

	if((err = send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "ctrl", error_msg(err), "read_BurstCount()");
	}
	else if(sscanf(ans, "%lu", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "ctrl", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_BurstCount()");
	}
	else
	{
		CORBA::string_free(ans);
		*attr_BurstCount_read = value;
	}

	//	Set the attribute value
	attr.set_value(attr_BurstCount_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::read_BurstCount
}
//--------------------------------------------------------
/**
 *	Write attribute BurstCount related method
 *	Description: The number of delay cyles generated on each trigger when in burst mode. The valid range covers [1..2^32-1].
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::write_BurstCount(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::write_BurstCount(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevULong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Control::write_BurstCount) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int ret = 0;

	sprintf(buffer, "BURC%u", w_val);
	if((ret = send_cmd(buffer)))
	{
		error(ret, ret < 0 && ret > -256 ? "dg645" : "ctrl", error_msg(ret), "write_BurstCount()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::write_BurstCount
}
//--------------------------------------------------------
/**
 *	Read attribute BurstPeriod related method
 *	Description: The period between delay cycles when in burst mode.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::read_BurstPeriod(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::read_BurstPeriod(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::read_BurstPeriod) ENABLED START -----*/
	int err;
	double value = 0;
	Tango::DevString ans;
	char cmd[] = "BURP?";

	if((err = send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "ctrl", error_msg(err), "read_BurstPeriod()");
	}
	else if(sscanf(ans, "%lf", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "ctrl", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_BurstPeriod()");
	}
	else
	{
		CORBA::string_free(ans);
		*attr_BurstPeriod_read = value * 1000;
	}

	//	Set the attribute value
	attr.set_value(attr_BurstPeriod_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::read_BurstPeriod
}
//--------------------------------------------------------
/**
 *	Write attribute BurstPeriod related method
 *	Description: The period between delay cycles when in burst mode.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::write_BurstPeriod(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::write_BurstPeriod(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Control::write_BurstPeriod) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int ret = 0;

	sprintf(buffer, "BURP%f", w_val / 1000);
	if((ret = send_cmd(buffer)))
	{
		error(ret, ret < 0 && ret > -256 ? "dg645" : "ctrl", error_msg(ret), "write_BurstPeriod()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::write_BurstPeriod
}
//--------------------------------------------------------
/**
 *	Read attribute BurstDelay related method
 *	Description: The added insertion delay from the trigger to the first delay cycle when in burst mode.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::read_BurstDelay(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::read_BurstDelay(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::read_BurstDelay) ENABLED START -----*/
	int err;
	double value = 0;
	Tango::DevString ans;
	char cmd[] = "BURD?";

	if((err = send_cmd(cmd, &ans)))
	{
		CORBA::string_free(ans);
		error(err, err < 0 && err > -256 ? "dg645" : "ctrl", error_msg(err), "read_BurstDelay()");
	}
	else if(sscanf(ans, "%lf", &value) != 1)
	{
		CORBA::string_free(ans);
		error(DG645_ERR_UNEXPECTED_ANSWER, "ctrl", error_msg(DG645_ERR_UNEXPECTED_ANSWER), "read_BurstDelay()");
	}
	else
	{
		CORBA::string_free(ans);
		*attr_BurstDelay_read = value * 1000;
	}

	//	Set the attribute value
	attr.set_value(attr_BurstDelay_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::read_BurstDelay
}
//--------------------------------------------------------
/**
 *	Write attribute BurstDelay related method
 *	Description: The added insertion delay from the trigger to the first delay cycle when in burst mode.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::write_BurstDelay(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::write_BurstDelay(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(StanfordDG645Control::write_BurstDelay) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int ret = 0;

	sprintf(buffer, "BURD%f", w_val / 1000);
	if((ret = send_cmd(buffer)))
	{
		error(ret, ret < 0 && ret > -256 ? "dg645" : "ctrl", error_msg(ret), "write_BurstDelay()");
	}
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::write_BurstDelay
}
//--------------------------------------------------------
/**
 *	Read attribute DeviceSerialNumber related method
 *	Description: Serial number of the delay generator.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::read_DeviceSerialNumber(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::read_DeviceSerialNumber(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::read_DeviceSerialNumber) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_DeviceSerialNumber_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::read_DeviceSerialNumber
}
//--------------------------------------------------------
/**
 *	Read attribute DeviceFirmwareVersion related method
 *	Description: Firmware version of the delay generator.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void StanfordDG645Control::read_DeviceFirmwareVersion(Tango::Attribute &attr)
{
	DEBUG_STREAM << "StanfordDG645Control::read_DeviceFirmwareVersion(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::read_DeviceFirmwareVersion) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_DeviceFirmwareVersion_read);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::read_DeviceFirmwareVersion
}

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Control::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void StanfordDG645Control::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(StanfordDG645Control::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command SingleShot related method
 *	Description: When the DG645 is configured for single shot triggers, this command initiates a single trigger. When it is configured for externally triggered single shots, this command arms the DG645 to trigger on the next detected external trigger.
 *
 */
//--------------------------------------------------------
void StanfordDG645Control::single_shot()
{
	DEBUG_STREAM << "StanfordDG645Control::SingleShot()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::single_shot) ENABLED START -----*/
	int ret;

	if((ret = send_cmd((char *)"*TRG")))
	{
		error(ret, ret < 0 && ret > -256 ? "dg645" : "ctrl", error_msg(ret), "single_shot()");
	}

	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::single_shot
}
//--------------------------------------------------------
/**
 *	Command LoadDefaults related method
 *	Description: Resets the device to it`s default UI_settings.
 *
 */
//--------------------------------------------------------
void StanfordDG645Control::load_defaults()
{
	DEBUG_STREAM << "StanfordDG645Control::LoadDefaults()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::load_defaults) ENABLED START -----*/
	int ret;

	if((ret = send_cmd((char *)"*RST")))
	{
		error(ret, ret < 0 && ret > -256 ? "dg645" : "ctrl", error_msg(ret), "load_defaults()");
	}

	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::load_defaults
}
//--------------------------------------------------------
/**
 *	Command LoadSettings related method
 *	Description: Reads back the previously saved instrument UI_settings from location [1..9].
 *
 *	@param argin 
 */
//--------------------------------------------------------
void StanfordDG645Control::load_settings(Tango::DevUShort argin)
{
	DEBUG_STREAM << "StanfordDG645Control::LoadSettings()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::load_settings) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int ret = 0;

	sprintf(buffer, "*RCL%d", argin);
	if((ret = send_cmd(buffer)))
	{
		error(ret, ret < 0 && ret > -256 ? "dg645" : "ctrl", error_msg(ret), "load_settings()");
	}

	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::load_settings
}
//--------------------------------------------------------
/**
 *	Command SaveSettings related method
 *	Description: Saves the current instrument UI_settings to location [1..9].
 *
 *	@param argin 
 */
//--------------------------------------------------------
void StanfordDG645Control::save_settings(Tango::DevUShort argin)
{
	DEBUG_STREAM << "StanfordDG645Control::SaveSettings()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::save_settings) ENABLED START -----*/
	char buffer[DG645_BUFFER_SIZE];
	int ret = 0;

	sprintf(buffer, "*SAV%d", argin);
	if((ret = send_cmd(buffer)))
	{
		error(ret, ret < 0 && ret > -256 ? "dg645" : "ctrl", error_msg(ret), "save_settings()");
	}

	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::save_settings
}
//--------------------------------------------------------
/**
 *	Command WriteRead related method
 *	Description: Writes the argument string to the delay generator and returns the answer.
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevString StanfordDG645Control::write_read(Tango::DevString argin)
{
	Tango::DevString argout;
	DEBUG_STREAM << "StanfordDG645Control::WriteRead()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(StanfordDG645Control::write_read) ENABLED START -----*/
	unsigned int i;
	int ret, len, size;
	char *buffer, *temp;
	string cmd;
	fd_set sready;
	struct timeval timeout;

	// append LF
	cmd.assign(argin);
	cmd.append("\n");

	// allocate buffer
	if((buffer = (char *)malloc(DG645_BUFFER_SIZE)) == NULL)
	{
		error(DG645_ERR_OUT_OF_MEMORY, "ctrl", error_msg(DG645_ERR_OUT_OF_MEMORY), "write_read()");
	}

	// only one command at a time
	connectionMutex.lock();

	// send request
	DEBUG_STREAM << "send: " << argin << endl;
	if((ret = write(handle, cmd.c_str(), cmd.length())) == (int)cmd.length())
	{
		ret = 0;
		len = 0;
		size = DG645_BUFFER_SIZE;

		for(i=0; i<DG645_TIMEOUT_S*10000 && ret == 0; i++)
		{
			// wait for packets
			timeout.tv_sec = 0;
			timeout.tv_usec = 100;
			FD_ZERO(&sready);
			FD_SET(handle, &sready);
			ret = select(handle + 1, &sready, NULL, NULL, &timeout);
			if(ret < 0)
			{
				ret = errno;
				break;
			}

			// read if ready
			if (ret > 0 && FD_ISSET(handle, &sready))
			{
				len += read(handle, &buffer[len], size - len);
				i = 0;
				ret = 0;
			}

			// answer is terminated with LF - exit
			if(!ret && buffer[len-1] == '\n')
				break;

			// extend buffer
			if(len == size)
			{
				temp = buffer;
				if((buffer = (char *)realloc(buffer, size + DG645_BUFFER_SIZE)) == NULL)
				{
					ret = DG645_ERR_OUT_OF_MEMORY;
					buffer = temp;
					buffer[len] = 0;
					break;
				}
				size += DG645_BUFFER_SIZE;
			}
		}

		// timeout
		if(i >= DG645_TIMEOUT_S*10000)
			ret = ETIMEDOUT;

		buffer[len] = 0;
		DEBUG_STREAM << "recv: " << buffer << endl;
	}
	else
		ret = errno;

	connectionMutex.unlock();

	if(ret)
	{
		// close handle
		close(handle);
		handle = 0;
		last_error = ret;

		// call hook
		hooks->executeHook(DG645_HOOK_CONNECTION_STOP);
		reconnect();

		free(buffer);
		set_state(Tango::FAULT);
		error(ret, "ctrl", error_msg(ret), "write_read()");
	}

	argout = CORBA::string_dup(buffer);
	free(buffer);
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::write_read
	return argout;
}
//--------------------------------------------------------
/**
 *	Method      : StanfordDG645Control::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void StanfordDG645Control::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(StanfordDG645Control::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::add_dynamic_commands
}

/*----- PROTECTED REGION ID(StanfordDG645Control::namespace_ending) ENABLED START -----*/

//	Additional Methods

//--------------------------------------------------------
/**
 *	Method      : reconnect
 *	Description : Spawns a background thread with a reconnection job.
 */
//--------------------------------------------------------
void StanfordDG645Control::reconnect(bool force)
{
	if(((!handle && !connecting && autoReconnect) || force) &&
			(!reconnect_thread || reconnect_thread->state() != omni_thread::STATE_RUNNING))
	{
		connecting = true;
		reconnect_thread = omni_thread::create(&init_connection, (void *)this);
	}
}

//--------------------------------------------------------
/**
 *	Method      : init_connection
 *	Description : Connects to the device and initializes it.
 *
 *	@returns int errno on error, 0 on success
 */
//--------------------------------------------------------
void *StanfordDG645Control::init_connection(void *arg)
{
	char yes=1;
	int ret;
	struct addrinfo* ai;
	struct addrinfo hints;
	struct timeval timeout;
	fd_set fds;
	unsigned long interval = 1171875000; //300s / 2^8 in ns
	StanfordDG645Control *server = (StanfordDG645Control *)arg;
	char *pos=0;
	Tango::DevString ans;
	bool connected = false;

	if(server->get_logger()->is_debug_enabled())
		server->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log <<
		"StanfordDG645Control::init_connection() entering... " << endl;

	// open connection
	while(server->connecting)
	{
		// set up connection parameters
		timeout.tv_sec = DG645_TIMEOUT_S;
		timeout.tv_usec = 0;
		memset(&hints, 0, sizeof(struct addrinfo));
		hints.ai_family = AF_INET; // DG645 depends on IPv4
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_protocol = IPPROTO_TCP;

		// resolve address
		if(!(ret = getaddrinfo(server->host.c_str(), DG645_REMOTE_PORT, &hints, &ai)))
		{
			while(true)
			{
				// open socket
				if((server->handle = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) < 0) break;

				// set nonblocking
				if(ioctl(server->handle, FIONBIO, &yes) < 0) break;

				// set timeout
				if(setsockopt(server->handle, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout, sizeof(struct timeval))) break;
				if(setsockopt(server->handle, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(struct timeval))) break;

				// Connect socket
				if(connect(server->handle, ai->ai_addr, ai->ai_addrlen))
				{
					ret = errno;
					if(ret && ret != EINPROGRESS)
						break;
				}

				// wait for connection
				FD_ZERO(&fds);
				FD_SET(server->handle, &fds);
				if((ret = select(server->handle + 1, NULL, &fds, NULL, &timeout)) < 0) break;
				if(ret == 0)
				{	// time out
					ret = ETIMEDOUT;
					break;
				}
				ret = 0;

				// clear buffer
				connectionMutex.lock();
				write(server->handle, "\n", 1);
				server->nsleep(100000000);
				server->flush_socket(server->handle);
				connectionMutex.unlock();

				// enable advanced triggering for holdoff and prescaling
				ret = server->send_cmd((char *)"ADVT1", &ans);
				CORBA::string_free(ans);
				if(ret)
					break;

				// read out id string
				ret = server->send_cmd((char *)"*IDN?", &ans);
				if(ret)
				{
					CORBA::string_free(ans);
					break;
				}

				// connection established if we got here
				freeaddrinfo(ai);
				connected = true;
				break;
			}

			// handle errors
			if(!connected)
			{
				if(!ret)
					ret = errno;
				close(server->handle);
				server->handle = 0;
				freeaddrinfo(ai);
			}

		}

		// file errors, close connection and wait before next try
		if(ret)
		{
			if(ret > 0)
				server->error(ret, "sys", strerror(ret), "init_connection()", false, true);
			server->last_error = ret;
			server->set_state(Tango::FAULT);
			for(unsigned long i=0; i<interval && server->connecting; i+=100000000)
				server->nsleep(100000000);
			if(interval < 300000000000)
				interval *= 2;
		}
		else break;
	}

	// parse id string
	pos = strrchr(ans, ',');
	if(pos)
	{
		*server->attr_DeviceFirmwareVersion_read = pos + 4;
		*pos = 0;
		if(!server->hardwareInfo)
			CORBA::string_free(server->hardwareInfo);
		server->hardwareInfo = ans;
		pos = strrchr(ans, ',');
		if(pos)
			*server->attr_DeviceSerialNumber_read = pos + 4;
		else
			server->error(DG645_ERR_UNEXPECTED_ANSWER, "ctrl", server->error_msg(DG645_ERR_UNEXPECTED_ANSWER), "init_connection()", false, true);
	}
	else
	{
		CORBA::string_free(ans);
		server->error(DG645_ERR_UNEXPECTED_ANSWER, "ctrl", server->error_msg(DG645_ERR_UNEXPECTED_ANSWER), "init_connection()", false, true);
	}

	if(server->get_logger()->is_debug_enabled())
		server->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log <<
		"StanfordDG645Control::init_connection() leaving " << endl;

	// call hook
	server->hooks->executeHook(DG645_HOOK_CONNECTION_START);

	server->set_state(Tango::ON);
	server->set_status(Tango::StatusNotSet);
	server->connecting = false;
	return NULL;
}


//--------------------------------------------------------
/**
 *	Poll data:
 *	Description: Continuously looks for arriving messages and
 *	             interprets them
 *
 *	@param void *arg
 *	@returns NULL
 */
//--------------------------------------------------------
void *StanfordDG645Control::poll_state(void *arg)
{
	int err=0;
	Tango::DevString ans;
	StanfordDG645Control *server = (StanfordDG645Control *)arg;

	server->running = true;
	server->terminated = false;

	if(server->get_logger()->is_debug_enabled())
		server->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log <<
		"StanfordDG645Control::poll_state() entering... " << endl;

	while(server->running)
	{
		if(server->handle && !server->connecting)
		{
			try
			{
				ans = server->write_read((Tango::DevString)"LERR?");
			}
			catch(CORBA::Exception &e)
			{
				err = server->get_reason(e);
			}

			// check answer, parse device errors
			if(!err && strlen(ans) <= 0)
				err = DG645_ERR_UNEXPECTED_ANSWER;
			else if(!err)
				err = atoi(ans);

			if(err)
			{
				if(server->last_error != err)
				{
					server->error(err, err < 0 && err > -256 ? "dg645" : "ctrl", server->error_msg(err), "poll_state()", false, true);
					server->last_error = err;
				}
				err = 0;
			}
		}
		server->nsleep(1000000000);
	}

	if(server->get_logger()->is_debug_enabled())
		server->get_logger()->debug_stream() << log4tango::LogInitiator::_begin_log <<
		"StanfordDG645Control::poll_state() leaving... " << endl;
	server->terminated = true;

	return NULL;
}


//--------------------------------------------------------
/**
 *	Method      : send_cmd
 *	Description : method to send commands to the device
 *
 *	@returns int errno on error, 0 on success
 */
//--------------------------------------------------------
int StanfordDG645Control::send_cmd(char *cmd , Tango::DevString *answer)
{
	Tango::DevString ans;
	char *temp;
	char buffer[DG645_BUFFER_SIZE];
	int ret = 0;

	sprintf(buffer, "%s;*OPC?;LERR?", cmd);

	// send command
	try
	{
		ans = write_read((Tango::DevString)buffer);
	}
	catch(CORBA::Exception &e)
	{
		ret = -get_reason(e);
		ans = CORBA::string_dup("");
	}

	// check answer, parse device errors
	if(!ret && strlen(ans) <= 0)
		ret = DG645_ERR_UNEXPECTED_ANSWER;
	else if(strrchr(ans, ';') && sscanf(strrchr(ans, ';') + 1, "%d", &ret) != 1)
		ret = DG645_ERR_UNEXPECTED_ANSWER;
	else
	{
		ret = -ret;
		if((temp = strchr(ans, ';')))
			temp[0] = 0;
	}

	// return answer if applicable
	if(answer != NULL)
		*answer = ans;
	else
		CORBA::string_free(ans);

	return ret;
}


//--------------------------------------------------------
/**
 *	Method      : get_reason
 *	Description : parses a Tango exception and returns the underlying error code
 *
 *	@param const CORBA::Exception &e
 */
//--------------------------------------------------------
int StanfordDG645Control::get_reason(const CORBA::Exception &e)
{

	const CORBA::UserException *ue;
	const Tango::DevFailed *te;
	const Tango::NamedDevFailedList *mdf;

	string reason = "";
	int ret;

	// If it is a CORBA::UserException
	if((ue = dynamic_cast<const CORBA::UserException *>(&e)) != NULL)
	{
		if((mdf = dynamic_cast<const Tango::NamedDevFailedList *>(&e)) != NULL)
		{
			if(mdf->errors.length() > 0)
			{
				reason = mdf->errors[0].reason.in();
			}
			else if(mdf->err_list.size() > 0)
			{
				reason = mdf->err_list[0].err_stack[0].reason.in();
			}
		}

		// Print the Tango::DevFailed exception contents
		else if((te = dynamic_cast<const Tango::DevFailed *>(&e)) != NULL)
		{
			if(te->errors.length() > 0)
			{
				reason = te->errors[0].reason.in();
			}
		}
	}

	ret = atoi(reason.c_str());
	return ret ? ret : DG645_ERR_UNKNOWN;
}


//--------------------------------------------------------
/**
 *	Method      : error_msg
 *	Description : return the message to an error code
 *
 *	@param int code
 *	@returns const char*
 */
//--------------------------------------------------------
const char inline *StanfordDG645Control::error_msg(int code)
{
	if(code < 0)
		return StanfordDG645Common_ns::DG645ErrorMsgs(code);
	else
		return strerror(code);
}


//--------------------------------------------------------
/**
 *	Method      : error
 *	Description : Sign an error. It's printed to the info stream and,
 *	              depending on throw_exception, also thrown as a Tango exception
 *
 *	@param int code, const char *module, const char *msg, const char *origin,
 *	       bool throw_exception, bool set_status_string
 */
//--------------------------------------------------------
void StanfordDG645Control::error(int code, const char *module, const char *msg, const char *origin, bool throw_exception, bool set_status_string)
{
	string buffer;
	char err[8];

	buffer.append(module);
	buffer.append(": ");
	buffer.append(msg);
	sprintf(err, "%i", code);

	ERROR_STREAM << buffer << ", error " << err << ", " << origin << endl;

	if(set_status_string)
	{
		status.assign(buffer);
		status.append(", error ");
		status.append(err);
		status.append(", ");
		status.append(origin);
		set_status(status);
	}

	if(throw_exception)
	{
		Tango::Except::throw_exception(CORBA::string_dup(err), CORBA::string_dup(buffer.c_str()), string(origin), Tango::ERR);
	}
}


//--------------------------------------------------------
/**
 *	Method      : nsleep
 *	Description : sleeps for nsec nano seconds
 *
 *	@param long nsec
 *	@returns int
 */
//--------------------------------------------------------
int StanfordDG645Control::nsleep(long nsec)
{
  struct timespec ts;

  ts.tv_sec = nsec / 1000000000;
  ts.tv_nsec = nsec % 1000000000;

  return nanosleep(&ts, NULL);
}


//--------------------------------------------------------
/**
 *	Method      : flush_socket
 *	Description : clears the receive buffer
 */
//--------------------------------------------------------
void StanfordDG645Control::flush_socket(int handle)
{
	int ret;
	char buffer[DG645_BUFFER_SIZE];
	fd_set sready;
	struct timeval nowait;

	FD_ZERO(&sready);
	FD_SET(handle, &sready);
	memset((char *)&nowait, 0, sizeof(nowait));
	if(handle==-1) handle = this->handle;

	ret = select(handle + 1, &sready, NULL, NULL, &nowait);
	while(ret > 0 && FD_ISSET(handle, &sready))
	{
		ret = read(handle, buffer, DG645_BUFFER_SIZE);
		ret = select(handle + 1, &sready, NULL, NULL, &nowait);
	}
}

/*----- PROTECTED REGION END -----*/	//	StanfordDG645Control::namespace_ending
} //	namespace
