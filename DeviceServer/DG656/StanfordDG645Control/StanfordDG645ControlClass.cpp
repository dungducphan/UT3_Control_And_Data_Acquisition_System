/*----- PROTECTED REGION ID(StanfordDG645ControlClass.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        StanfordDG645ControlClass.cpp
//
// description : C++ source for the StanfordDG645ControlClass.
//               A singleton class derived from DeviceClass.
//               It implements the command and attribute list
//               and all properties and methods required
//               by the StanfordDG645Control once per process.
//
// project :     StanfordDG645Control
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <StanfordDG645ControlClass.h>

/*----- PROTECTED REGION END -----*/	//	StanfordDG645ControlClass.cpp

//-------------------------------------------------------------------
/**
 *	Create StanfordDG645ControlClass singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_StanfordDG645Control_class(const char *name) {
		return StanfordDG645Control_ns::StanfordDG645ControlClass::init(name);
	}
}

namespace StanfordDG645Control_ns
{
//===================================================================
//	Initialize pointer for singleton pattern
//===================================================================
StanfordDG645ControlClass *StanfordDG645ControlClass::_instance = NULL;

//--------------------------------------------------------
/**
 * method : 		StanfordDG645ControlClass::StanfordDG645ControlClass(string &s)
 * description : 	constructor for the StanfordDG645ControlClass
 *
 * @param s	The class name
 */
//--------------------------------------------------------
StanfordDG645ControlClass::StanfordDG645ControlClass(string &s):Tango::DeviceClass(s)
{
	cout2 << "Entering StanfordDG645ControlClass constructor" << endl;
	set_default_property();
	write_class_property();

	/*----- PROTECTED REGION ID(StanfordDG645ControlClass::constructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645ControlClass::constructor

	cout2 << "Leaving StanfordDG645ControlClass constructor" << endl;
}

//--------------------------------------------------------
/**
 * method : 		StanfordDG645ControlClass::~StanfordDG645ControlClass()
 * description : 	destructor for the StanfordDG645ControlClass
 */
//--------------------------------------------------------
StanfordDG645ControlClass::~StanfordDG645ControlClass()
{
	/*----- PROTECTED REGION ID(StanfordDG645ControlClass::destructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645ControlClass::destructor

	_instance = NULL;
}


//--------------------------------------------------------
/**
 * method : 		StanfordDG645ControlClass::init
 * description : 	Create the object if not already done.
 *                  Otherwise, just return a pointer to the object
 *
 * @param	name	The class name
 */
//--------------------------------------------------------
StanfordDG645ControlClass *StanfordDG645ControlClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new StanfordDG645ControlClass(s);
		}
		catch (bad_alloc &)
		{
			throw;
		}
	}
	return _instance;
}

//--------------------------------------------------------
/**
 * method : 		StanfordDG645ControlClass::instance
 * description : 	Check if object already created,
 *                  and return a pointer to the object
 */
//--------------------------------------------------------
StanfordDG645ControlClass *StanfordDG645ControlClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}



//===================================================================
//	Command execution method calls
//===================================================================
//--------------------------------------------------------
/**
 * method : 		SingleShotClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SingleShotClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "SingleShotClass::execute(): arrived" << endl;
	((static_cast<StanfordDG645Control *>(device))->single_shot());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		LoadDefaultsClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *LoadDefaultsClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "LoadDefaultsClass::execute(): arrived" << endl;
	((static_cast<StanfordDG645Control *>(device))->load_defaults());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		LoadSettingsClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *LoadSettingsClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "LoadSettingsClass::execute(): arrived" << endl;
	Tango::DevUShort argin;
	extract(in_any, argin);
	((static_cast<StanfordDG645Control *>(device))->load_settings(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SaveSettingsClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SaveSettingsClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "SaveSettingsClass::execute(): arrived" << endl;
	Tango::DevUShort argin;
	extract(in_any, argin);
	((static_cast<StanfordDG645Control *>(device))->save_settings(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		WriteReadClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *WriteReadClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "WriteReadClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	return insert((static_cast<StanfordDG645Control *>(device))->write_read(argin));
}


//===================================================================
//	Properties management
//===================================================================
//--------------------------------------------------------
/**
 *	Method      : StanfordDG645ControlClass::get_class_property()
 *	Description : Get the class property for specified name.
 */
//--------------------------------------------------------
Tango::DbDatum StanfordDG645ControlClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, returns  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645ControlClass::get_default_device_property()
 *	Description : Return the default value for device property.
 */
//--------------------------------------------------------
Tango::DbDatum StanfordDG645ControlClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645ControlClass::get_default_class_property()
 *	Description : Return the default value for class property.
 */
//--------------------------------------------------------
Tango::DbDatum StanfordDG645ControlClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}


//--------------------------------------------------------
/**
 *	Method      : StanfordDG645ControlClass::set_default_property()
 *	Description : Set default property (class and device) for wizard.
 *                For each property, add to wizard property name and description.
 *                If default value has been set, add it to wizard property and
 *                store it in a DbDatum.
 */
//--------------------------------------------------------
void StanfordDG645ControlClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;
	vector<string>	vect_data;

	//	Set Default Class Properties

	//	Set Default device Properties
	prop_name = "Host";
	prop_desc = "Hostname or IP address to the device.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "AutoReconnect";
	prop_desc = "Whether the server will automatically try to reconnect on errors.";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
}

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645ControlClass::write_class_property()
 *	Description : Set class description fields as property in database
 */
//--------------------------------------------------------
void StanfordDG645ControlClass::write_class_property()
{
	//	First time, check if database used
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("StanfordDG645Control");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("Device server for the Stanford DG645 delay generator. Exports the connection to dedicated single channel device servers.");
	description << str_desc;
	data.push_back(description);

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("TANGO_BASE_CLASS");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	get_db_class()->put_property(data);
}

//===================================================================
//	Factory methods
//===================================================================

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645ControlClass::device_factory()
 *	Description : Create the device object(s)
 *                and store them in the device list
 */
//--------------------------------------------------------
void StanfordDG645ControlClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{
	/*----- PROTECTED REGION ID(StanfordDG645ControlClass::device_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645ControlClass::device_factory_before

	//	Create devices and add it into the device list
	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
		device_list.push_back(new StanfordDG645Control(this, (*devlist_ptr)[i]));
	}

	//	Manage dynamic attributes if any
	erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

	//	Export devices to the outside world
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++)
	{
		//	Add dynamic attributes if any
		StanfordDG645Control *dev = static_cast<StanfordDG645Control *>(device_list[device_list.size()-i]);
		dev->add_dynamic_attributes();

		//	Check before if database used.
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(dev);
		else
			export_device(dev, dev->get_name().c_str());
	}

	/*----- PROTECTED REGION ID(StanfordDG645ControlClass::device_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645ControlClass::device_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : StanfordDG645ControlClass::attribute_factory()
 *	Description : Create the attribute object(s)
 *                and store them in the attribute list
 */
//--------------------------------------------------------
void StanfordDG645ControlClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	/*----- PROTECTED REGION ID(StanfordDG645ControlClass::attribute_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645ControlClass::attribute_factory_before
	//	Attribute : TriggerMode
	TriggerModeAttrib	*triggermode = new TriggerModeAttrib();
	Tango::UserDefaultAttrProp	triggermode_prop;
	triggermode_prop.set_description("Int - Internal triggering at rates from 100 µHz to 10 MHz.\nExtRisingEdge - External triggering on rising edges.\nExtFallingEdge - External triggering on falling edges.\nSingleExtRisingEdge - Externally triggered single shot on a rising edges. Execute SingleShot command to arm the trigger.\nSingleExtFallingEdge - Externally triggered single shot on a falling edges. Execute SingleShot command to arm the trigger.\nSingle - Single shot triggering. Initiated manually on the device or by executing the SingleShot command.\nLine - Trigger at the power line frequency.");
	//	label	not set for TriggerMode
	//	unit	not set for TriggerMode
	//	standard_unit	not set for TriggerMode
	//	display_unit	not set for TriggerMode
	//	format	not set for TriggerMode
	//	max_value	not set for TriggerMode
	//	min_value	not set for TriggerMode
	//	max_alarm	not set for TriggerMode
	//	min_alarm	not set for TriggerMode
	//	max_warning	not set for TriggerMode
	//	min_warning	not set for TriggerMode
	//	delta_t	not set for TriggerMode
	//	delta_val	not set for TriggerMode
	
	{
		vector<string> labels;
		labels.push_back("Int");
		labels.push_back("ExtRisingEdge");
		labels.push_back("ExtFallingEdge");
		labels.push_back("SingleExtRisingEdge");
		labels.push_back("SingleExtFallingEdge");
		labels.push_back("Single");
		labels.push_back("Line");
		triggermode_prop.set_enum_labels(labels);
	}
	triggermode->set_default_properties(triggermode_prop);
	//	Not Polled
	triggermode->set_disp_level(Tango::OPERATOR);
	triggermode->set_memorized();
	triggermode->set_memorized_init(true);
	att_list.push_back(triggermode);

	//	Attribute : TriggerRate
	TriggerRateAttrib	*triggerrate = new TriggerRateAttrib();
	Tango::UserDefaultAttrProp	triggerrate_prop;
	triggerrate_prop.set_description("The frequency of the trigger generator used in internal mode. It can generate triggers at rates from 100 uHz to 10 MHz with 1 uHz resolution.");
	//	label	not set for TriggerRate
	triggerrate_prop.set_unit("Hz");
	triggerrate_prop.set_standard_unit("Hz");
	triggerrate_prop.set_display_unit("Hz");
	triggerrate_prop.set_format("%12.4f");
	triggerrate_prop.set_max_value("10000000");
	triggerrate_prop.set_min_value("0.0001");
	//	max_alarm	not set for TriggerRate
	//	min_alarm	not set for TriggerRate
	//	max_warning	not set for TriggerRate
	//	min_warning	not set for TriggerRate
	//	delta_t	not set for TriggerRate
	//	delta_val	not set for TriggerRate
	
	triggerrate->set_default_properties(triggerrate_prop);
	//	Not Polled
	triggerrate->set_disp_level(Tango::OPERATOR);
	triggerrate->set_memorized();
	triggerrate->set_memorized_init(true);
	att_list.push_back(triggerrate);

	//	Attribute : TriggerThreshold
	TriggerThresholdAttrib	*triggerthreshold = new TriggerThresholdAttrib();
	Tango::UserDefaultAttrProp	triggerthreshold_prop;
	triggerthreshold_prop.set_description("The Ext Trig input threshold range is +-3.5 VDC.");
	//	label	not set for TriggerThreshold
	triggerthreshold_prop.set_unit("V");
	triggerthreshold_prop.set_standard_unit("V");
	triggerthreshold_prop.set_display_unit("V");
	triggerthreshold_prop.set_format("%3.2f");
	triggerthreshold_prop.set_max_value("3.5");
	triggerthreshold_prop.set_min_value("-3.5");
	//	max_alarm	not set for TriggerThreshold
	//	min_alarm	not set for TriggerThreshold
	//	max_warning	not set for TriggerThreshold
	//	min_warning	not set for TriggerThreshold
	//	delta_t	not set for TriggerThreshold
	//	delta_val	not set for TriggerThreshold
	
	triggerthreshold->set_default_properties(triggerthreshold_prop);
	//	Not Polled
	triggerthreshold->set_disp_level(Tango::OPERATOR);
	triggerthreshold->set_memorized();
	triggerthreshold->set_memorized_init(true);
	att_list.push_back(triggerthreshold);

	//	Attribute : TriggerHoldoff
	TriggerHoldoffAttrib	*triggerholdoff = new TriggerHoldoffAttrib();
	Tango::UserDefaultAttrProp	triggerholdoff_prop;
	triggerholdoff_prop.set_description("The minimum allowed time between successive triggers. For example, if the trigger holdoff is set to 10 ms, then successive triggers will be ignored until at least 10 ms have passed since the last accepted trigger. Makes use of the advanced triggering mode.");
	//	label	not set for TriggerHoldoff
	triggerholdoff_prop.set_unit("ms");
	triggerholdoff_prop.set_standard_unit("ms");
	triggerholdoff_prop.set_display_unit("ms");
	triggerholdoff_prop.set_format("%15.8f");
	triggerholdoff_prop.set_max_value("2000000");
	triggerholdoff_prop.set_min_value("0");
	//	max_alarm	not set for TriggerHoldoff
	//	min_alarm	not set for TriggerHoldoff
	//	max_warning	not set for TriggerHoldoff
	//	min_warning	not set for TriggerHoldoff
	//	delta_t	not set for TriggerHoldoff
	//	delta_val	not set for TriggerHoldoff
	
	triggerholdoff->set_default_properties(triggerholdoff_prop);
	//	Not Polled
	triggerholdoff->set_disp_level(Tango::OPERATOR);
	triggerholdoff->set_memorized();
	triggerholdoff->set_memorized_init(true);
	att_list.push_back(triggerholdoff);

	//	Attribute : TriggerPrescale
	TriggerPrescaleAttrib	*triggerprescale = new TriggerPrescaleAttrib();
	Tango::UserDefaultAttrProp	triggerprescale_prop;
	triggerprescale_prop.set_description("This is a divider to the original trigger frequency. If set to values > 1, only every Nth trigger will initiate a delay cyle. The valid range covers [1..2^30-1], 1 will disable the feature. Makes use of  the advanced triggering mode when.");
	//	label	not set for TriggerPrescale
	//	unit	not set for TriggerPrescale
	//	standard_unit	not set for TriggerPrescale
	//	display_unit	not set for TriggerPrescale
	triggerprescale_prop.set_format("%d");
	triggerprescale_prop.set_max_value("1073741824");
	triggerprescale_prop.set_min_value("1");
	//	max_alarm	not set for TriggerPrescale
	//	min_alarm	not set for TriggerPrescale
	//	max_warning	not set for TriggerPrescale
	//	min_warning	not set for TriggerPrescale
	//	delta_t	not set for TriggerPrescale
	//	delta_val	not set for TriggerPrescale
	
	triggerprescale->set_default_properties(triggerprescale_prop);
	//	Not Polled
	triggerprescale->set_disp_level(Tango::OPERATOR);
	triggerprescale->set_memorized();
	triggerprescale->set_memorized_init(true);
	att_list.push_back(triggerprescale);

	//	Attribute : BurstMode
	BurstModeAttrib	*burstmode = new BurstModeAttrib();
	Tango::UserDefaultAttrProp	burstmode_prop;
	burstmode_prop.set_description("The delay generator will generate a burst of N delay cycles on each trigger when enabled.");
	//	label	not set for BurstMode
	//	unit	not set for BurstMode
	//	standard_unit	not set for BurstMode
	//	display_unit	not set for BurstMode
	//	format	not set for BurstMode
	//	max_value	not set for BurstMode
	//	min_value	not set for BurstMode
	//	max_alarm	not set for BurstMode
	//	min_alarm	not set for BurstMode
	//	max_warning	not set for BurstMode
	//	min_warning	not set for BurstMode
	//	delta_t	not set for BurstMode
	//	delta_val	not set for BurstMode
	
	burstmode->set_default_properties(burstmode_prop);
	//	Not Polled
	burstmode->set_disp_level(Tango::OPERATOR);
	burstmode->set_memorized();
	burstmode->set_memorized_init(true);
	att_list.push_back(burstmode);

	//	Attribute : BurstCount
	BurstCountAttrib	*burstcount = new BurstCountAttrib();
	Tango::UserDefaultAttrProp	burstcount_prop;
	burstcount_prop.set_description("The number of delay cyles generated on each trigger when in burst mode. The valid range covers [1..2^32-1].");
	//	label	not set for BurstCount
	//	unit	not set for BurstCount
	//	standard_unit	not set for BurstCount
	//	display_unit	not set for BurstCount
	burstcount_prop.set_format("%d");
	burstcount_prop.set_max_value("4294967295");
	burstcount_prop.set_min_value("1");
	//	max_alarm	not set for BurstCount
	//	min_alarm	not set for BurstCount
	//	max_warning	not set for BurstCount
	//	min_warning	not set for BurstCount
	//	delta_t	not set for BurstCount
	//	delta_val	not set for BurstCount
	
	burstcount->set_default_properties(burstcount_prop);
	//	Not Polled
	burstcount->set_disp_level(Tango::OPERATOR);
	burstcount->set_memorized();
	burstcount->set_memorized_init(true);
	att_list.push_back(burstcount);

	//	Attribute : BurstPeriod
	BurstPeriodAttrib	*burstperiod = new BurstPeriodAttrib();
	Tango::UserDefaultAttrProp	burstperiod_prop;
	burstperiod_prop.set_description("The period between delay cycles when in burst mode.");
	//	label	not set for BurstPeriod
	burstperiod_prop.set_unit("ms");
	burstperiod_prop.set_standard_unit("ms");
	burstperiod_prop.set_display_unit("ms");
	burstperiod_prop.set_format("%6.3f");
	burstperiod_prop.set_max_value("100000");
	burstperiod_prop.set_min_value("0.00000001");
	//	max_alarm	not set for BurstPeriod
	//	min_alarm	not set for BurstPeriod
	//	max_warning	not set for BurstPeriod
	//	min_warning	not set for BurstPeriod
	//	delta_t	not set for BurstPeriod
	//	delta_val	not set for BurstPeriod
	
	burstperiod->set_default_properties(burstperiod_prop);
	//	Not Polled
	burstperiod->set_disp_level(Tango::OPERATOR);
	burstperiod->set_memorized();
	burstperiod->set_memorized_init(true);
	att_list.push_back(burstperiod);

	//	Attribute : BurstDelay
	BurstDelayAttrib	*burstdelay = new BurstDelayAttrib();
	Tango::UserDefaultAttrProp	burstdelay_prop;
	burstdelay_prop.set_description("The added insertion delay from the trigger to the first delay cycle when in burst mode.");
	//	label	not set for BurstDelay
	burstdelay_prop.set_unit("ms");
	burstdelay_prop.set_standard_unit("ms");
	burstdelay_prop.set_display_unit("ms");
	burstdelay_prop.set_format("%15.8f");
	burstdelay_prop.set_max_value("2000000");
	burstdelay_prop.set_min_value("0");
	//	max_alarm	not set for BurstDelay
	//	min_alarm	not set for BurstDelay
	//	max_warning	not set for BurstDelay
	//	min_warning	not set for BurstDelay
	//	delta_t	not set for BurstDelay
	//	delta_val	not set for BurstDelay
	
	burstdelay->set_default_properties(burstdelay_prop);
	//	Not Polled
	burstdelay->set_disp_level(Tango::OPERATOR);
	burstdelay->set_memorized();
	burstdelay->set_memorized_init(true);
	att_list.push_back(burstdelay);

	//	Attribute : DeviceSerialNumber
	DeviceSerialNumberAttrib	*deviceserialnumber = new DeviceSerialNumberAttrib();
	Tango::UserDefaultAttrProp	deviceserialnumber_prop;
	deviceserialnumber_prop.set_description("Serial number of the delay generator.");
	//	label	not set for DeviceSerialNumber
	//	unit	not set for DeviceSerialNumber
	//	standard_unit	not set for DeviceSerialNumber
	//	display_unit	not set for DeviceSerialNumber
	//	format	not set for DeviceSerialNumber
	//	max_value	not set for DeviceSerialNumber
	//	min_value	not set for DeviceSerialNumber
	//	max_alarm	not set for DeviceSerialNumber
	//	min_alarm	not set for DeviceSerialNumber
	//	max_warning	not set for DeviceSerialNumber
	//	min_warning	not set for DeviceSerialNumber
	//	delta_t	not set for DeviceSerialNumber
	//	delta_val	not set for DeviceSerialNumber
	
	deviceserialnumber->set_default_properties(deviceserialnumber_prop);
	//	Not Polled
	deviceserialnumber->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(deviceserialnumber);

	//	Attribute : DeviceFirmwareVersion
	DeviceFirmwareVersionAttrib	*devicefirmwareversion = new DeviceFirmwareVersionAttrib();
	Tango::UserDefaultAttrProp	devicefirmwareversion_prop;
	devicefirmwareversion_prop.set_description("Firmware version of the delay generator.");
	//	label	not set for DeviceFirmwareVersion
	//	unit	not set for DeviceFirmwareVersion
	//	standard_unit	not set for DeviceFirmwareVersion
	//	display_unit	not set for DeviceFirmwareVersion
	//	format	not set for DeviceFirmwareVersion
	//	max_value	not set for DeviceFirmwareVersion
	//	min_value	not set for DeviceFirmwareVersion
	//	max_alarm	not set for DeviceFirmwareVersion
	//	min_alarm	not set for DeviceFirmwareVersion
	//	max_warning	not set for DeviceFirmwareVersion
	//	min_warning	not set for DeviceFirmwareVersion
	//	delta_t	not set for DeviceFirmwareVersion
	//	delta_val	not set for DeviceFirmwareVersion
	
	devicefirmwareversion->set_default_properties(devicefirmwareversion_prop);
	//	Not Polled
	devicefirmwareversion->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(devicefirmwareversion);


	//	Create a list of static attributes
	create_static_attribute_list(get_class_attr()->get_attr_list());
	/*----- PROTECTED REGION ID(StanfordDG645ControlClass::attribute_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645ControlClass::attribute_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : StanfordDG645ControlClass::pipe_factory()
 *	Description : Create the pipe object(s)
 *                and store them in the pipe list
 */
//--------------------------------------------------------
void StanfordDG645ControlClass::pipe_factory()
{
	/*----- PROTECTED REGION ID(StanfordDG645ControlClass::pipe_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645ControlClass::pipe_factory_before
	/*----- PROTECTED REGION ID(StanfordDG645ControlClass::pipe_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645ControlClass::pipe_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : StanfordDG645ControlClass::command_factory()
 *	Description : Create the command object(s)
 *                and store them in the command list
 */
//--------------------------------------------------------
void StanfordDG645ControlClass::command_factory()
{
	/*----- PROTECTED REGION ID(StanfordDG645ControlClass::command_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645ControlClass::command_factory_before


	//	Command SingleShot
	SingleShotClass	*pSingleShotCmd =
		new SingleShotClass("SingleShot",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSingleShotCmd);

	//	Command LoadDefaults
	LoadDefaultsClass	*pLoadDefaultsCmd =
		new LoadDefaultsClass("LoadDefaults",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pLoadDefaultsCmd);

	//	Command LoadSettings
	LoadSettingsClass	*pLoadSettingsCmd =
		new LoadSettingsClass("LoadSettings",
			Tango::DEV_USHORT, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pLoadSettingsCmd);

	//	Command SaveSettings
	SaveSettingsClass	*pSaveSettingsCmd =
		new SaveSettingsClass("SaveSettings",
			Tango::DEV_USHORT, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSaveSettingsCmd);

	//	Command WriteRead
	WriteReadClass	*pWriteReadCmd =
		new WriteReadClass("WriteRead",
			Tango::DEV_STRING, Tango::DEV_STRING,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pWriteReadCmd);

	/*----- PROTECTED REGION ID(StanfordDG645ControlClass::command_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645ControlClass::command_factory_after
}

//===================================================================
//	Dynamic attributes related methods
//===================================================================

//--------------------------------------------------------
/**
 * method : 		StanfordDG645ControlClass::create_static_attribute_list
 * description : 	Create the a list of static attributes
 *
 * @param	att_list	the ceated attribute list
 */
//--------------------------------------------------------
void StanfordDG645ControlClass::create_static_attribute_list(vector<Tango::Attr *> &att_list)
{
	for (unsigned long i=0 ; i<att_list.size() ; i++)
	{
		string att_name(att_list[i]->get_name());
		transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
		defaultAttList.push_back(att_name);
	}

	cout2 << defaultAttList.size() << " attributes in default list" << endl;

	/*----- PROTECTED REGION ID(StanfordDG645ControlClass::create_static_att_list) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645ControlClass::create_static_att_list
}


//--------------------------------------------------------
/**
 * method : 		StanfordDG645ControlClass::erase_dynamic_attributes
 * description : 	delete the dynamic attributes if any.
 *
 * @param	devlist_ptr	the device list pointer
 * @param	list of all attributes
 */
//--------------------------------------------------------
void StanfordDG645ControlClass::erase_dynamic_attributes(const Tango::DevVarStringArray *devlist_ptr, vector<Tango::Attr *> &att_list)
{
	Tango::Util *tg = Tango::Util::instance();

	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		Tango::DeviceImpl *dev_impl = tg->get_device_by_name(((string)(*devlist_ptr)[i]).c_str());
		StanfordDG645Control *dev = static_cast<StanfordDG645Control *> (dev_impl);

		vector<Tango::Attribute *> &dev_att_list = dev->get_device_attr()->get_attribute_list();
		vector<Tango::Attribute *>::iterator ite_att;
		for (ite_att=dev_att_list.begin() ; ite_att != dev_att_list.end() ; ++ite_att)
		{
			string att_name((*ite_att)->get_name_lower());
			if ((att_name == "state") || (att_name == "status"))
				continue;
			vector<string>::iterator ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
			if (ite_str == defaultAttList.end())
			{
				cout2 << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << endl;
				Tango::Attribute &att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
				dev->remove_attribute(att_list[att.get_attr_idx()], true, false);
				--ite_att;
			}
		}
	}
	/*----- PROTECTED REGION ID(StanfordDG645ControlClass::erase_dynamic_attributes) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	StanfordDG645ControlClass::erase_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Method      : StanfordDG645ControlClass::get_attr_object_by_name()
 *	Description : returns Tango::Attr * object found by name
 */
//--------------------------------------------------------
Tango::Attr *StanfordDG645ControlClass::get_attr_object_by_name(vector<Tango::Attr *> &att_list, string attname)
{
	vector<Tango::Attr *>::iterator it;
	for (it=att_list.begin() ; it<att_list.end() ; ++it)
		if ((*it)->get_name()==attname)
			return (*it);
	//	Attr does not exist
	return NULL;
}


/*----- PROTECTED REGION ID(StanfordDG645ControlClass::Additional Methods) ENABLED START -----*/

/*----- PROTECTED REGION END -----*/	//	StanfordDG645ControlClass::Additional Methods
} //	namespace
